<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	java.lang.Object - xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="OS.html">OS</a></li>
						
						  <li id=""><a target="_self" href="Algorithms.html">Algorithms</a></li>
						
						  <li id=""><a target="_self" href="NetWork.html">NetWork</a></li>
						
						  <li id=""><a target="_self" href="Apache.html">Apache</a></li>
						
						  <li id=""><a target="_self" href="Nginx.html">Nginx</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="JVM.html">JVM</a></li>
						
						  <li id=""><a target="_self" href="NoSQL.html">NoSQL</a></li>
						
						  <li id=""><a target="_self" href="Zookeeper.html">Zookeeper</a></li>
						
						  <li id=""><a target="_self" href="MQ.html">MQ</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						  <li id=""><a target="_self" href="jdkSource.html">jdkSource</a></li>
						
						  <li id=""><a target="_self" href="AboutMe.html">AboutMe</a></li>
						
						  <li id=""><a target="_self" href="Case.html">Case</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">java.lang.Object</h1>
		<div class="entry-content" itemprop="articleBody">
			<blockquote>
<p>jdk1.6 类 java.lang.Object</p>

<p>转自<a href="http://www.runoob.com/manual/jdk1.6/java/lang/Object.html#wait(long)">类 Object</a></p>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">java.lang.Object</a>
</li>
</ul>


<h2 id="toc_0">java.lang.Object</h2>

<ol>
<li>getClass()</li>
<li>hashCode()</li>
<li>equals(Object obj)</li>
<li>clone()</li>
<li>toString()</li>
<li>notify()</li>
<li>notifyAll()</li>
<li>wait(long timeout)</li>
<li>wait(long timeout, int nanos)</li>
<li>wait()</li>
<li>finalize()</li>
</ol>

<pre><code class="language-java">/*
 * %W% %E%
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package java.lang;

/**
 * Class &lt;code&gt;Object&lt;/code&gt; is the root of the class hierarchy. 
 * Every class has &lt;code&gt;Object&lt;/code&gt; as a superclass. All objects, 
 * including arrays, implement the methods of this class. 
 *
 * @author  unascribed
 * @version %I%, %G%
 * @see     java.lang.Class
 * @since   JDK1.0
 */
public class Object {

    private static native void registerNatives();
    static {
        registerNatives();
    }

    /**
     * Returns the runtime class of this {@code Object}. The returned
     * {@code Class} object is the object that is locked by {@code
     * static synchronized} methods of the represented class.
     *
     * &lt;p&gt;&lt;b&gt;The actual result type is {@code Class&lt;? extends |X|&gt;}
     * where {@code |X|} is the erasure of the static type of the
     * expression on which {@code getClass} is called.&lt;/b&gt; For
     * example, no cast is required in this code fragment:&lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code Number n = 0;                             }&lt;br&gt;
     * {@code Class&lt;? extends Number&gt; c = n.getClass(); }
     * &lt;/p&gt;
     *
     * @return The {@code Class} object that represents the runtime
     *         class of this object.
     * @see    &lt;a href=&quot;http://java.sun.com/docs/books/jls/&quot;&gt;The Java
     *         Language Specification, Third Edition (15.8.2 Class
     *         Literals)&lt;/a&gt;
     */
    /**
     * 返回此 Object 的运行时类。返回的 Class 对象是由所表示类的 
     * static synchronized 方法锁定的对象。
     * 实际结果类型是 Class&lt;? extends |X|&gt;，其中 |X| 表示清除表达式中的静态类型，
     * 该表达式调用 getClass。 例如，以下代码片段中不需要强制转换：
     * 
     * Number n = 0; 
     * Class&lt;? extends Number&gt; c = n.getClass();
     * 
     * 返回：
     * 表示此对象运行时类的 Class 对象。
     * 另请参见：
     * The Java Language Specification, Third Edition (15.8.2 Class Literals)
     */
    public final native Class&lt;?&gt; getClass();

    /**
     * Returns a hash code value for the object. This method is 
     * supported for the benefit of hashtables such as those provided by 
     * &lt;code&gt;java.util.Hashtable&lt;/code&gt;. 
     * &lt;p&gt;
     * The general contract of &lt;code&gt;hashCode&lt;/code&gt; is: 
     * &lt;ul&gt;
     * &lt;li&gt;Whenever it is invoked on the same object more than once during 
     *     an execution of a Java application, the &lt;tt&gt;hashCode&lt;/tt&gt; method 
     *     must consistently return the same integer, provided no information 
     *     used in &lt;tt&gt;equals&lt;/tt&gt; comparisons on the object is modified.
     *     This integer need not remain consistent from one execution of an
     *     application to another execution of the same application. 
     * &lt;li&gt;If two objects are equal according to the &lt;tt&gt;equals(Object)&lt;/tt&gt;
     *     method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of 
     *     the two objects must produce the same integer result. 
     * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal 
     *     according to the {@link java.lang.Object#equals(java.lang.Object)} 
     *     method, then calling the &lt;tt&gt;hashCode&lt;/tt&gt; method on each of the 
     *     two objects must produce distinct integer results.  However, the 
     *     programmer should be aware that producing distinct integer results 
     *     for unequal objects may improve the performance of hashtables.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As much as is reasonably practical, the hashCode method defined by 
     * class &lt;tt&gt;Object&lt;/tt&gt; does return distinct integers for distinct 
     * objects. (This is typically implemented by converting the internal 
     * address of the object into an integer, but this implementation 
     * technique is not required by the 
     * Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.)
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.util.Hashtable
     */
    /**
     * 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 
     * 提供的哈希表）的性能。
     * hashCode 的常规协定是：
     * 
     * 1. 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地
     * 返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用
     * 程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。
     * 2. 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象
     * 调用 hashCode 方法都必须生成相同的整数结果。
     * 3. 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象
     * 中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该
     * 意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。
     * 
     * 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。
     * （这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言
     * 不需要这种实现技巧。）
     * 
     * 返回：
     * 此对象的一个哈希码值。
     * 另请参见：
     * equals(java.lang.Object), Hashtable
     */
    public native int hashCode();

    /**
     * Indicates whether some other object is &quot;equal to&quot; this one.
     * &lt;p&gt;
     * The &lt;code&gt;equals&lt;/code&gt; method implements an equivalence relation
     * on non-null object references:
     * &lt;ul&gt;
     * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value
     *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(x)&lt;/code&gt; should return
     *     &lt;code&gt;true&lt;/code&gt;.
     * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values
     *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;x.equals(y)&lt;/code&gt;
     *     should return &lt;code&gt;true&lt;/code&gt; if and only if
     *     &lt;code&gt;y.equals(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.
     * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values
     *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if
     *     &lt;code&gt;x.equals(y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; and
     *     &lt;code&gt;y.equals(z)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then
     *     &lt;code&gt;x.equals(z)&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt;.
     * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values
     *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, multiple invocations of
     *     &lt;tt&gt;x.equals(y)&lt;/tt&gt; consistently return &lt;code&gt;true&lt;/code&gt;
     *     or consistently return &lt;code&gt;false&lt;/code&gt;, provided no
     *     information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the
     *     objects is modified.
     * &lt;li&gt;For any non-null reference value &lt;code&gt;x&lt;/code&gt;,
     *     &lt;code&gt;x.equals(null)&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The &lt;tt&gt;equals&lt;/tt&gt; method for class &lt;code&gt;Object&lt;/code&gt; implements 
     * the most discriminating possible equivalence relation on objects; 
     * that is, for any non-null reference values &lt;code&gt;x&lt;/code&gt; and
     * &lt;code&gt;y&lt;/code&gt;, this method returns &lt;code&gt;true&lt;/code&gt; if and only
     * if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer to the same object
     * (&lt;code&gt;x == y&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;).
     * &lt;p&gt;
     * Note that it is generally necessary to override the &lt;tt&gt;hashCode&lt;/tt&gt;
     * method whenever this method is overridden, so as to maintain the
     * general contract for the &lt;tt&gt;hashCode&lt;/tt&gt; method, which states
     * that equal objects must have equal hash codes. 
     *
     * @param   obj   the reference object with which to compare.
     * @return  &lt;code&gt;true&lt;/code&gt; if this object is the same as the obj
     *          argument; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see     #hashCode()
     * @see     java.util.Hashtable
     */
    /**
     * 指示其他某个对象是否与此对象“相等”。
     * equals 方法在非空对象引用上实现相等关系：
     * 
     * 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。
     * 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，
     *           x.equals(y) 才应返回 true。
     * 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，
     *           并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。
     * 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 
     *           或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。
     * 对于任何非空引用值 x，x.equals(null) 都应返回 false。
     * 
     * Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何
     * 非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true
     * （x == y 具有值 true）。
     * 
     * 注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的
     * 常规协定，该协定声明相等对象必须具有相等的哈希码。
     * 
     * 参数：
     * obj - 要与之比较的引用对象。
     * 返回：
     * 如果此对象与 obj 参数相同，则返回 true；否则返回 false。
     * 另请参见：
     * hashCode(), Hashtable
     */

    public boolean equals(Object obj) {
    return (this == obj);
    }

    /**
     * Creates and returns a copy of this object.  The precise meaning 
     * of &quot;copy&quot; may depend on the class of the object. The general 
     * intent is that, for any object &lt;tt&gt;x&lt;/tt&gt;, the expression:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;
     * will be true, and that the expression:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;
     * will be &lt;tt&gt;true&lt;/tt&gt;, but these are not absolute requirements. 
     * While it is typically the case that:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;
     * will be &lt;tt&gt;true&lt;/tt&gt;, this is not an absolute requirement. 
     * &lt;p&gt;
     * By convention, the returned object should be obtained by calling
     * &lt;tt&gt;super.clone&lt;/tt&gt;.  If a class and all of its superclasses (except
     * &lt;tt&gt;Object&lt;/tt&gt;) obey this convention, it will be the case that
     * &lt;tt&gt;x.clone().getClass() == x.getClass()&lt;/tt&gt;.
     * &lt;p&gt;
     * By convention, the object returned by this method should be independent
     * of this object (which is being cloned).  To achieve this independence,
     * it may be necessary to modify one or more fields of the object returned
     * by &lt;tt&gt;super.clone&lt;/tt&gt; before returning it.  Typically, this means
     * copying any mutable objects that comprise the internal &quot;deep structure&quot;
     * of the object being cloned and replacing the references to these
     * objects with references to the copies.  If a class contains only
     * primitive fields or references to immutable objects, then it is usually
     * the case that no fields in the object returned by &lt;tt&gt;super.clone&lt;/tt&gt;
     * need to be modified.
     * &lt;p&gt;
     * The method &lt;tt&gt;clone&lt;/tt&gt; for class &lt;tt&gt;Object&lt;/tt&gt; performs a 
     * specific cloning operation. First, if the class of this object does 
     * not implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;, then a 
     * &lt;tt&gt;CloneNotSupportedException&lt;/tt&gt; is thrown. Note that all arrays 
     * are considered to implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;. 
     * Otherwise, this method creates a new instance of the class of this 
     * object and initializes all its fields with exactly the contents of 
     * the corresponding fields of this object, as if by assignment; the
     * contents of the fields are not themselves cloned. Thus, this method 
     * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.
     * &lt;p&gt;
     * The class &lt;tt&gt;Object&lt;/tt&gt; does not itself implement the interface 
     * &lt;tt&gt;Cloneable&lt;/tt&gt;, so calling the &lt;tt&gt;clone&lt;/tt&gt; method on an object 
     * whose class is &lt;tt&gt;Object&lt;/tt&gt; will result in throwing an
     * exception at run time.
     *
     * @return     a clone of this instance.
     * @exception  CloneNotSupportedException  if the object&#39;s class does not
     *               support the &lt;code&gt;Cloneable&lt;/code&gt; interface. Subclasses
     *               that override the &lt;code&gt;clone&lt;/code&gt; method can also
     *               throw this exception to indicate that an instance cannot
     *               be cloned.
     * @see java.lang.Cloneable
     */
    /**
     * 创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。这样做的目的是，
     * 对于任何对象 x，表达式：x.clone() != x 为 true，
     * 表达式：x.clone().getClass() == x.getClass() 也为 true，
     * 但这些并非必须要满足的要求。一般情况下：x.clone().equals(x)为 true，
     * 但这并非必须要满足的要求。
     * 按照惯例，返回的对象应该通过调用 super.clone 获得。如果一个类及其所有的
     * 超类（Object 除外）都遵守此约定，则 x.clone().getClass() == x.getClass()。
     * 
     * 按照惯例，此方法返回的对象应该独立于该对象（正被复制的对象）。要获得此独立性，
     * 在 super.clone 返回对象之前，有必要对该对象的一个或多个字段进行修改。
     * 这通常意味着要复制包含正在被复制对象的内部“深层结构”的所有可变对象，
     * 并使用对副本的引用替换对这些对象的引用。
     * 如果一个类只包含基本字段或对不变对象的引用，那么通常不需要修改 super.clone 
     * 返回的对象中的字段。
     * 
     * Object 类的 clone 方法执行特定的复制操作。首先，如果此对象的类不能实现
     * 接口 Cloneable，则会抛出 CloneNotSupportedException。
     * 注意，所有的数组都被视为实现接口 Cloneable。否则，此方法会创建此对象的类的
     * 一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；
     * 这些字段的内容没有被自我复制。所以，此方法执行的是该对象的“浅表复制”，
     * 而不“深层复制”操作。
     * 
     * Object 类本身不实现接口 Cloneable，所以在类为 Object 的对象上调用 clone 方法
     * 将会导致在运行时抛出异常。
     * 
     * 返回：
     * 此实例的一个副本。
     * 抛出：
     * CloneNotSupportedException - 如果对象的类不支持 Cloneable 接口，
     * 则重写 clone 方法的子类也会抛出此异常，以指示无法复制某个实例。
     * 另请参见：
     * Cloneable
     */
    protected native Object clone() throws CloneNotSupportedException;

    /**
     * Returns a string representation of the object. In general, the 
     * &lt;code&gt;toString&lt;/code&gt; method returns a string that 
     * &quot;textually represents&quot; this object. The result should 
     * be a concise but informative representation that is easy for a 
     * person to read.
     * It is recommended that all subclasses override this method.
     * &lt;p&gt;
     * The &lt;code&gt;toString&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt; 
     * returns a string consisting of the name of the class of which the 
     * object is an instance, the at-sign character `&lt;code&gt;@&lt;/code&gt;&#39;, and 
     * the unsigned hexadecimal representation of the hash code of the 
     * object. In other words, this method returns a string equal to the 
     * value of:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     * getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  a string representation of the object.
     */
    /**
     * 返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”
     * 此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。
     * 
     * Object 类的 toString 方法返回一个字符串，该字符串由类名
     * （对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。
     * 换句话说，该方法返回一个字符串，它的值等于：
     * getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())
     * 
     * 返回：
     * 该对象的字符串表示形式。
     */
    public String toString() {
    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }

    /**
     * Wakes up a single thread that is waiting on this object&#39;s 
     * monitor. If any threads are waiting on this object, one of them 
     * is chosen to be awakened. The choice is arbitrary and occurs at 
     * the discretion of the implementation. A thread waits on an object&#39;s 
     * monitor by calling one of the &lt;code&gt;wait&lt;/code&gt; methods.
     * &lt;p&gt;
     * The awakened thread will not be able to proceed until the current 
     * thread relinquishes the lock on this object. The awakened thread will 
     * compete in the usual manner with any other threads that might be 
     * actively competing to synchronize on this object; for example, the 
     * awakened thread enjoys no reliable privilege or disadvantage in being 
     * the next thread to lock this object.
     * &lt;p&gt;
     * This method should only be called by a thread that is the owner 
     * of this object&#39;s monitor. A thread becomes the owner of the 
     * object&#39;s monitor in one of three ways: 
     * &lt;ul&gt;
     * &lt;li&gt;By executing a synchronized instance method of that object. 
     * &lt;li&gt;By executing the body of a &lt;code&gt;synchronized&lt;/code&gt; statement 
     *     that synchronizes on the object. 
     * &lt;li&gt;For objects of type &lt;code&gt;Class,&lt;/code&gt; by executing a 
     *     synchronized static method of that class. 
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Only one thread at a time can own an object&#39;s monitor. 
     *
     * @exception  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object&#39;s monitor.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    /**
     * 唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，
     * 则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。
     * 线程通过调用其中一个 wait 方法，在对象的监视器上等待。
     * 
     * 直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。
     * 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
     * 例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。
     * 
     * 此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，
     * 线程可以成为此对象监视器的所有者：
     * 
     * 1. 通过执行此对象的同步实例方法。
     * 2. 通过执行在此对象上进行同步的 synchronized 语句的正文。
     * 3. 对于 Class 类型的对象，可以通过执行该类的同步静态方法。
     * 
     * 一次只能有一个线程拥有对象的监视器。
     * 
     * 抛出：
     * IllegalMonitorStateException - 如果当前线程不是此对象监视器的所有者。
     * 另请参见：
     * notifyAll(), wait()
     */
    public final native void notify();

    /**
     * Wakes up all threads that are waiting on this object&#39;s monitor. A 
     * thread waits on an object&#39;s monitor by calling one of the 
     * &lt;code&gt;wait&lt;/code&gt; methods.
     * &lt;p&gt;
     * The awakened threads will not be able to proceed until the current 
     * thread relinquishes the lock on this object. The awakened threads 
     * will compete in the usual manner with any other threads that might 
     * be actively competing to synchronize on this object; for example, 
     * the awakened threads enjoy no reliable privilege or disadvantage in 
     * being the next thread to lock this object.
     * &lt;p&gt;
     * This method should only be called by a thread that is the owner 
     * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a 
     * description of the ways in which a thread can become the owner of 
     * a monitor. 
     *
     * @exception  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object&#39;s monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
    /**
     * 唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个 wait 方法，
     * 在对象的监视器上等待。
     * 
     * 直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。
     * 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
     * 例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。
     * 
     * 此方法只应由作为此对象监视器的所有者的线程来调用。
     * 有关线程能够成为监视器所有者的方法的描述，请参阅 notify 方法。
     * 
     * 抛出：
     * IllegalMonitorStateException - 如果当前线程不是此对象监视器的所有者。
     * 另请参见：
     * notify(), wait()
     */
    public final native void notifyAll();

    /**
     * Causes the current thread to wait until either another thread invokes the 
     * {@link java.lang.Object#notify()} method or the 
     * {@link java.lang.Object#notifyAll()} method for this object, or a 
     * specified amount of time has elapsed. 
     * &lt;p&gt;
     * The current thread must own this object&#39;s monitor. 
     * &lt;p&gt;
     * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to 
     * place itself in the wait set for this object and then to relinquish 
     * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt; 
     * becomes disabled for thread scheduling purposes and lies dormant 
     * until one of four things happens:
     * &lt;ul&gt;
     * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notify&lt;/tt&gt; method for this 
     * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as 
     * the thread to be awakened. 
     * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notifyAll&lt;/tt&gt; method for this 
     * object. 
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt() interrupts} 
     * thread &lt;var&gt;T&lt;/var&gt;. 
     * &lt;li&gt;The specified amount of real time has elapsed, more or less.  If 
     * &lt;tt&gt;timeout&lt;/tt&gt; is zero, however, then real time is not taken into 
     * consideration and the thread simply waits until notified. 
     * &lt;/ul&gt;
     * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this 
     * object and re-enabled for thread scheduling. It then competes in the 
     * usual manner with other threads for the right to synchronize on the 
     * object; once it has gained control of the object, all its 
     * synchronization claims on the object are restored to the status quo 
     * ante - that is, to the situation as of the time that the &lt;tt&gt;wait&lt;/tt&gt; 
     * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the 
     * invocation of the &lt;tt&gt;wait&lt;/tt&gt; method. Thus, on return from the 
     * &lt;tt&gt;wait&lt;/tt&gt; method, the synchronization state of the object and of 
     * thread &lt;tt&gt;T&lt;/tt&gt; is exactly as it was when the &lt;tt&gt;wait&lt;/tt&gt; method 
     * was invoked. 
     * &lt;p&gt;
     * A thread can also wake up without being notified, interrupted, or
     * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;.  While this will rarely
     * occur in practice, applications must guard against it by testing for
     * the condition that should have caused the thread to be awakened, and
     * continuing to wait if the condition is not satisfied.  In other words,
     * waits should always occur in loops, like this one:
     * &lt;pre&gt;
     *     synchronized (obj) {
     *         while (&amp;lt;condition does not hold&amp;gt;)
     *             obj.wait(timeout);
     *         ... // Perform action appropriate to condition
     *     }
     * &lt;/pre&gt;
     * (For more information on this topic, see Section 3.2.3 in Doug Lea&#39;s
     * &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley,
     * 2000), or Item 50 in Joshua Bloch&#39;s &quot;Effective Java Programming
     * Language Guide&quot; (Addison-Wesley, 2001).
     *
     * &lt;p&gt;If the current thread is {@linkplain java.lang.Thread#interrupt()
     * interrupted} by any thread before or while it is waiting, then an
     * &lt;tt&gt;InterruptedException&lt;/tt&gt; is thrown.  This exception is not
     * thrown until the lock status of this object has been restored as
     * described above.
     *
     * &lt;p&gt;
     * Note that the &lt;tt&gt;wait&lt;/tt&gt; method, as it places the current thread 
     * into the wait set for this object, unlocks only this object; any 
     * other objects on which the current thread may be synchronized remain 
     * locked while the thread waits.
     * &lt;p&gt;
     * This method should only be called by a thread that is the owner 
     * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a 
     * description of the ways in which a thread can become the owner of 
     * a monitor. 
     *
     * @param      timeout   the maximum time to wait in milliseconds.
     * @exception  IllegalArgumentException      if the value of timeout is
     *           negative.
     * @exception  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object&#39;s monitor.
     * @exception  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The &lt;i&gt;interrupted
     *             status&lt;/i&gt; of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    /**
     * 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，
     * 或者超过指定的时间量前，导致当前线程等待。当前线程必须拥有此对象监视器。
     * 
     * 此方法导致当前线程（称之为 T）将其自身放置在对象的等待集中，
     * 然后放弃此对象上的所有同步要求。出于线程调度目的，在发生以下四种情况之一前，
     * 线程 T 被禁用，且处于休眠状态：
     * 
     * 1. 其他某个线程调用此对象的 notify 方法，并且线程 T 碰巧被任选为被唤醒的线程。
     * 2. 其他某个线程调用此对象的 notifyAll 方法。
     * 3. 其他某个线程中断线程 T。
     * 4. 大约已经到达指定的实际时间。但是，如果 timeout 为零，则不考虑实际时间，
     *    在获得通知前该线程将一直等待。
     *    
     * 然后，从对象的等待集中删除线程 T，并重新进行线程调度。然后，该线程以常规方式与
     * 其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的
     * 所有其同步声明都将被恢复到以前的状态，这就是调用 wait 方法时的情况。然后，
     * 线程 T 从 wait 方法的调用中返回。所以，从 wait 方法返回时，该对象和线程 T 
     * 的同步状态与调用 wait 方法时的情况完全相同。在没有被通知、中断或超时的情况下，
     * 线程还可以唤醒一个所谓的虚假唤醒 (spurious wakeup)。虽然这种情况在实践中很少
     * 发生，但是应用程序必须通过以下方式防止其发生，即对应该导致该线程被提醒的条件
     * 进行测试，如果不满足该条件，则继续等待。换句话说，等待应总是发生在循环中，
     * 如下面的示例：
     *
     * synchronized (obj) {
     * while (&lt;condition does not hold&gt;)
     * obj.wait(timeout);
     * ... // Perform action appropriate to condition
     * }
     * 
     * （有关这一主题的更多信息，请参阅 Doug Lea 撰写的 Concurrent Programming 
     * in Java (Second Edition) (Addison-Wesley, 2000) 中的第 3.2.3 节
     * 或 Joshua Bloch 撰写的 Effective Java Programming Language Guide
     *  (Addison-Wesley, 2001) 中的第 50 项。
     * 
     * 如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 InterruptedException。
     * 在按上述形式恢复此对象的锁定状态时才会抛出此异常。
     * 
     * 注意，由于 wait 方法将当前线程放入了对象的等待集中，所以它只能解除此对象的锁定；
     * 可以同步当前线程的任何其他对象在线程等待时仍处于锁定状态。
     * 
     * 此方法只应由作为此对象监视器的所有者的线程来调用。有关线程能够成为监视器所有者
     * 的方法的描述，请参阅 notify 方法。
     * 
     * 参数：
     * timeout - 要等待的最长时间（以毫秒为单位）。
     * 抛出：
     * IllegalArgumentException - 如果超时值为负。
     * IllegalMonitorStateException - 如果当前线程不是此对象监视器的所有者。
     * InterruptedException - 如果在当前线程等待通知之前或者正在等待通知时，
     *      任何线程中断了当前线程。在抛出此异常时，当前线程的中断状态 被清除。
     * 另请参见：
     * notify(), notifyAll()
     */
    public final native void wait(long timeout) throws InterruptedException;

    /**
     * Causes the current thread to wait until another thread invokes the 
     * {@link java.lang.Object#notify()} method or the 
     * {@link java.lang.Object#notifyAll()} method for this object, or 
     * some other thread interrupts the current thread, or a certain 
     * amount of real time has elapsed. 
     * &lt;p&gt;
     * This method is similar to the &lt;code&gt;wait&lt;/code&gt; method of one 
     * argument, but it allows finer control over the amount of time to 
     * wait for a notification before giving up. The amount of real time, 
     * measured in nanoseconds, is given by:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     * 1000000*timeout+nanos&lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * In all other respects, this method does the same thing as the 
     * method {@link #wait(long)} of one argument. In particular, 
     * &lt;tt&gt;wait(0, 0)&lt;/tt&gt; means the same thing as &lt;tt&gt;wait(0)&lt;/tt&gt;.
     * &lt;p&gt;
     * The current thread must own this object&#39;s monitor. The thread 
     * releases ownership of this monitor and waits until either of the 
     * following two conditions has occurred: 
     * &lt;ul&gt;
     * &lt;li&gt;Another thread notifies threads waiting on this object&#39;s monitor 
     *     to wake up either through a call to the &lt;code&gt;notify&lt;/code&gt; method 
     *     or the &lt;code&gt;notifyAll&lt;/code&gt; method. 
     * &lt;li&gt;The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt; 
     *     milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has 
     *     elapsed. 
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The thread then waits until it can re-obtain ownership of the 
     * monitor and resumes execution.
     * &lt;p&gt;
     * As in the one argument version, interrupts and spurious wakeups are
     * possible, and this method should always be used in a loop:
     * &lt;pre&gt;
     *     synchronized (obj) {
     *         while (&amp;lt;condition does not hold&amp;gt;)
     *             obj.wait(timeout, nanos);
     *         ... // Perform action appropriate to condition
     *     }
     * &lt;/pre&gt;
     * This method should only be called by a thread that is the owner 
     * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a 
     * description of the ways in which a thread can become the owner of 
     * a monitor. 
     *
     * @param      timeout   the maximum time to wait in milliseconds.
     * @param      nanos      additional time, in nanoseconds range
     *                       0-999999.
     * @exception  IllegalArgumentException      if the value of timeout is
     *              negative or the value of nanos is
     *              not in the range 0-999999.
     * @exception  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object&#39;s monitor.
     * @exception  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The &lt;i&gt;interrupted
     *             status&lt;/i&gt; of the current thread is cleared when
     *             this exception is thrown.
     */
    /**
     * 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程
     * 中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。
     * 
     * 此方法类似于一个参数的 wait 方法，但它允许更好地控制在放弃之前等待通知的时间量。
     * 用毫微秒度量的实际时间量可以通过以下公式计算出来：
     * 1000000*timeout+nanos
     * 
     * 在其他所有方面，此方法执行的操作与带有一个参数的 wait(long) 方法相同。
     * 需要特别指出的是，wait(0, 0) 与 wait(0) 相同。
     * 
     * 当前线程必须拥有此对象监视器。该线程发布对此监视器的所有权，
     * 并等待下面两个条件之一发生：
     * 
     * 1. 其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上
     *      等待的线程醒来。
     * 2. timeout 毫秒值与 nanos 毫微秒参数值之和指定的超时时间已用完。
     * 
     * 然后，该线程等到重新获得对监视器的所有权后才能继续执行。
     * 
     * 对于某一个参数的版本，实现中断和虚假唤醒是有可能的，并且此方法应始终在循环中使用：
     * 
     * synchronized (obj) {
     * while (&lt;condition does not hold&gt;)
     * obj.wait(timeout, nanos);
     * ... // Perform action appropriate to condition
     * }
     * 
     * 此方法只应由作为此对象监视器的所有者的线程来调用。有关线程能够成为监视器所有者
     * 的方法的描述，请参阅 notify 方法。
     * 
     * 参数：
     * timeout - 要等待的最长时间（以毫秒为单位）。
     * nanos - 额外时间（以毫微秒为单位，范围是 0-999999）。
     * 抛出：
     * IllegalArgumentException - 如果超时值是负数，或者毫微秒值不在0-999999范围内。
     * IllegalMonitorStateException - 如果当前线程不是此对象监视器的所有者。
     * InterruptedException - 如果在当前线程等待通知之前或者正在等待通知时，
     *      任何线程中断了当前线程。在抛出此异常时，当前线程的中断状态 被清除。
     */
    public final void wait(long timeout, int nanos) throws InterruptedException {
          if (timeout &lt; 0) {
               throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
          }
          if (nanos &lt; 0 || nanos &gt; 999999) {
               throw new IllegalArgumentException(
              &quot;nanosecond timeout value out of range&quot;);
          }
          if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) {
               timeout++;
          }
        wait(timeout);
    }

    /**
     * Causes the current thread to wait until another thread invokes the 
     * {@link java.lang.Object#notify()} method or the 
     * {@link java.lang.Object#notifyAll()} method for this object. 
     * In other words, this method behaves exactly as if it simply 
     * performs the call &lt;tt&gt;wait(0)&lt;/tt&gt;.
     * &lt;p&gt;
     * The current thread must own this object&#39;s monitor. The thread 
     * releases ownership of this monitor and waits until another thread 
     * notifies threads waiting on this object&#39;s monitor to wake up 
     * either through a call to the &lt;code&gt;notify&lt;/code&gt; method or the 
     * &lt;code&gt;notifyAll&lt;/code&gt; method. The thread then waits until it can 
     * re-obtain ownership of the monitor and resumes execution. 
     * &lt;p&gt;
     * As in the one argument version, interrupts and spurious wakeups are
     * possible, and this method should always be used in a loop:
     * &lt;pre&gt;
     *     synchronized (obj) {
     *         while (&amp;lt;condition does not hold&amp;gt;)
     *             obj.wait();
     *         ... // Perform action appropriate to condition
     *     }
     * &lt;/pre&gt;
     * This method should only be called by a thread that is the owner 
     * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a 
     * description of the ways in which a thread can become the owner of 
     * a monitor. 
     *
     * @exception  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object&#39;s monitor.
     * @exception  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The &lt;i&gt;interrupted
     *             status&lt;/i&gt; of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    /**
     * 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
     * 换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。
     * 
     * 当前线程必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程
     * 通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。
     * 然后该线程将等到重新获得对监视器的所有权后才能继续执行。
     * 
     * 对于某一个参数的版本，实现中断和虚假唤醒是可能的，而且此方法应始终在循环中使用：
     * synchronized (obj) {
     * while (&lt;condition does not hold&gt;)
     * obj.wait();
     * ... // Perform action appropriate to condition
     * }
     * 
     * 此方法只应由作为此对象监视器的所有者的线程来调用。有关线程能够成为监视器所有者
     * 的方法的描述，请参阅 notify 方法。
     * 
     * 抛出：
     * IllegalMonitorStateException - 如果当前线程不是此对象监视器的所有者。
     * InterruptedException - 如果在当前线程等待通知之前或者正在等待通知时，
     *      任何线程中断了当前线程。在抛出此异常时，当前线程的中断状态 被清除。
     * 另请参见：
     * notify(), notifyAll()
     */
    public final void wait() throws InterruptedException {
          wait(0);
    }

    /**
     * Called by the garbage collector on an object when garbage collection
     * determines that there are no more references to the object.
     * A subclass overrides the &lt;code&gt;finalize&lt;/code&gt; method to dispose of
     * system resources or to perform other cleanup. 
     * &lt;p&gt;
     * The general contract of &lt;tt&gt;finalize&lt;/tt&gt; is that it is invoked 
     * if and when the Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; virtual 
     * machine has determined that there is no longer any
     * means by which this object can be accessed by any thread that has
     * not yet died, except as a result of an action taken by the
     * finalization of some other object or class which is ready to be
     * finalized. The &lt;tt&gt;finalize&lt;/tt&gt; method may take any action, including
     * making this object available again to other threads; the usual purpose
     * of &lt;tt&gt;finalize&lt;/tt&gt;, however, is to perform cleanup actions before 
     * the object is irrevocably discarded. For example, the finalize method 
     * for an object that represents an input/output connection might perform
     * explicit I/O transactions to break the connection before the object is
     * permanently discarded. 
     * &lt;p&gt;
     * The &lt;tt&gt;finalize&lt;/tt&gt; method of class &lt;tt&gt;Object&lt;/tt&gt; performs no 
     * special action; it simply returns normally. Subclasses of 
     * &lt;tt&gt;Object&lt;/tt&gt; may override this definition.
     * &lt;p&gt;
     * The Java programming language does not guarantee which thread will 
     * invoke the &lt;tt&gt;finalize&lt;/tt&gt; method for any given object. It is 
     * guaranteed, however, that the thread that invokes finalize will not 
     * be holding any user-visible synchronization locks when finalize is 
     * invoked. If an uncaught exception is thrown by the finalize method, 
     * the exception is ignored and finalization of that object terminates.
     * &lt;p&gt;
     * After the &lt;tt&gt;finalize&lt;/tt&gt; method has been invoked for an object, no 
     * further action is taken until the Java virtual machine has again 
     * determined that there is no longer any means by which this object can 
     * be accessed by any thread that has not yet died, including possible
     * actions by other objects or classes which are ready to be finalized, 
     * at which point the object may be discarded.
     * &lt;p&gt;
     * The &lt;tt&gt;finalize&lt;/tt&gt; method is never invoked more than once by a Java
     * virtual machine for any given object.
     * &lt;p&gt;
     * Any exception thrown by the &lt;code&gt;finalize&lt;/code&gt; method causes 
     * the finalization of this object to be halted, but is otherwise 
     * ignored. 
     *
     * @throws Throwable the &lt;code&gt;Exception&lt;/code&gt; raised by this method
     */
    /**
     * 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
     * 子类重写 finalize 方法，以配置系统资源或执行其他清除。
     * 
     * finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法
     * 再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象
     * 或类的终结操作执行了某个操作。
     * finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；
     * 不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。
     * 例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，
     * 以便在永久丢弃对象之前中断连接。
     * 
     * Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。
     * Object 的子类可以重写此定义。
     * 
     * Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。
     * 但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户
     * 可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，
     * 并且该对象的终结操作将终止。
     * 
     * 在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机
     * 再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止
     * 的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。
     * 
     * 对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。
     * 
     * finalize 方法抛出的任何异常都会导致此对象的终结操作停止，
     * 但可以通过其他方法忽略它。
     * 
     * 抛出：
     * Throwable - 此方法抛出的 Exception
     */
    protected void finalize() throws Throwable { }
}


</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>