<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Java中生产者消费者模型 - xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">Java中生产者消费者模型</h1>
		<div class="entry-content" itemprop="articleBody">
			<blockquote>
<p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，<br/>
它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。<br/>
解决生产者/消费者问题的方法可分为两类:</p>

<ol>
<li>采用某种机制保护生产者和消费者之间的同步；</li>
<li>在生产者和消费者之间建立一个管道。</li>
</ol>

<p>第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。<br/>
第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。<br/>
同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。<br/>
常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。<br/>
Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。<br/>
在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。</p>

<ol>
<li>wait() / notify()方法</li>
<li>await() / signal()方法</li>
<li>BlockingQueue阻塞队列方法</li>
<li>PipedInputStream / PipedOutputStream
本文介绍前三种方法</li>
</ol>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">1. 生产者消费者模型1 ProducerConsumerWaitNotifyTest</a>
</li>
<li>
<a href="#toc_1">2. 生产者消费者模型2 ProducerConsumerAwaitSignalTest</a>
</li>
<li>
<a href="#toc_2">3. 生产者消费者模型3 ProducerConsumerBlockingQueueTest</a>
</li>
</ul>


<h2 id="toc_0">1. 生产者消费者模型1 ProducerConsumerWaitNotifyTest</h2>

<pre><code class="language-java">package cn.altman.producerconsumer1.test;

/**
 * Created by xuzhihua on 1/8/2018.
 * 生产者消费者模型测试
 * 使用 wait() notify() 方法
 wait() / nofity()方法是基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样，我们就可以为任何对象实现同步机制。
 wait()方法：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等等状态，让其他线程执行。
 notify()方法：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。
 */

import java.util.LinkedList;

/**
 * 仓库类Storage实现缓冲区
 */
class Storage{
    // 仓库最大存储量
    private final int MAX_SIZE = 100;
    //  仓库存储的载体
    private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;();
    
    // 生产num个产品
    public void produce(int num){
        // 同步代码段
        synchronized(list){
            // 如果仓库剩余容量不足
            while (list.size() + num &gt; MAX_SIZE){
                System.out.println(&quot;[要生产的产品数量]: &quot;+num +
                        &quot;\t库存量: &quot; + list.size() +
                        &quot;\t 仓库最大容量: &quot; + MAX_SIZE +
                        &quot;\t暂时不能执行生产任务&quot;);
                try{
                    // 由于条件不满足，生产阻塞
                    list.wait();
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            // 生产条件满足情况下 生产num个产品
            for (int i = 1; i &lt;= num; ++i){
                list.add(new Object());
            }
            System.out.println(&quot;[已经生产产品数]: &quot; + num +
                    &quot;\t现仓储容量: &quot; + list.size());
            list.notifyAll();
        }
    }
    // 消费num个产品
    public void consume(int num){
        // 同步代码段
        synchronized (list){
            // 如果仓库存储量不足
            while (list.size() &lt; num){
                System.out.println(&quot;[要消费的产品数量]: &quot;+ num +
                        &quot;\t现库存量: &quot; + list.size() +
                        &quot;\t暂时不能执行消费任务&quot;);
                try{
                    // 由于条件不满足，消费阻塞
                    list.wait();
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            // 消费条件满足情况下，消费num个产品
            for (int i = 1; i &lt;= num; ++i){
                list.remove();
            }
            System.out.println(&quot;[已经消费产品数]: &quot;+ num +
                    &quot;\t现库存量: &quot; + list.size());
            list.notifyAll();
        }
    }
    // get/set方法
    public int getMAX_SIZE() {return MAX_SIZE;}
    public LinkedList&lt;Object&gt; getList() {return list;}
    public void setList(LinkedList&lt;Object&gt; list) {this.list = list;}
}

/**
 * 生产者类Procducer继承线程类Thread
 */
class Producer extends Thread{
    // 每次生产的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Producer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        produce(num);
    }
    // 调用仓库Storage的生产函数
    public void produce(int num){
        storage.produce(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}

/**
 * 消费者类Consumer继承线程类Thread
 */
class Consumer extends Thread{
    // 每次消费的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Consumer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        consume(num);
    }
    // 调用仓库Storage的消费函数
    public void consume(int num){
        storage.consume(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}
/**
 * 测试类 测试生产者消费者模型
 * */
public class ProducerConsumerWaitNotifyTest {
    public static void main(String[] args) {
        // 仓库对象
        Storage storage = new Storage();
        // 生产者对象
        Producer p1 = new Producer(storage);
        Producer p2 = new Producer(storage);
        Producer p3 = new Producer(storage);
        Producer p4 = new Producer(storage);
        Producer p5 = new Producer(storage);
        Producer p6 = new Producer(storage);
        Producer p7 = new Producer(storage);
        // 消费者对象
        Consumer c1 = new Consumer(storage);
        Consumer c2 = new Consumer(storage);
        Consumer c3 = new Consumer(storage);
        // 设置生产者产品生产数量
        p1.setNum(10);
        p2.setNum(10);
        p3.setNum(10);
        p4.setNum(10);
        p5.setNum(10);
        p6.setNum(10);
        p7.setNum(80);
        // 设置消费者产品消费数量
        c1.setNum(50);
        c2.setNum(20);
        c3.setNum(30);
        // 线程开始执行
        c1.start();
        c2.start();
        c3.start();
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
        p6.start();
        p7.start();
    }
</code></pre>

<p>输出结果<br/>
<img src="media/15179900699305/15179916040813.jpg" alt=""/></p>

<h2 id="toc_1">2. 生产者消费者模型2 ProducerConsumerAwaitSignalTest</h2>

<pre><code class="language-java">package cn.altman.producerconsumer2.test;

/**
 * Created by xuzhihua on 1/8/2018.
 * 生产者消费者模型测试
 * 使用 await() signal() 方法
 在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。
 await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和wait() / nofity()相同，完全可以取代它们，
 但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。
 通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全
 */


import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 仓库类Storage实现缓冲区
 */
class Storage{
    // 仓库最大存储量
    private final int MAX_SIZE = 100;
    // 仓库存储的载体
    private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;();
    // 锁
    private final Lock lock = new ReentrantLock();
    // 仓库满的条件变量
    private final Condition full = lock.newCondition();
    // 仓库空的条件变量
    private final Condition empty = lock.newCondition();
    
    // 生产num个产品
    public void produce(int num){
        // 获得锁
        lock.lock();
        // 如果仓库剩余容量不足
        while (list.size() + num &gt; MAX_SIZE){
            System.out.println(&quot;[要生产的产品数量]: &quot;+num +
                    &quot;\t库存量: &quot; + list.size() +&quot;&quot; +
                    &quot;\t 仓库最大容量: &quot; + MAX_SIZE +
                    &quot;\t暂时不能执行生产任务&quot;);
            try{
                // 由于条件不满足 生产阻塞
                full.await();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        // 生产条件满足情况下，生产num个产品
        for (int i = 1; i &lt;= num; ++i){
            list.add(new Object());
        }
        System.out.println(&quot;[已经生产产品数]: &quot; + num +
                &quot;\t现仓储容量: &quot; + list.size());
        // 唤醒其他所有线程
        full.signalAll();
        empty.signalAll();
        // 释放锁
        lock.unlock();
    }
    // 消费num个产品
    public void consume(int num){
        // 获得锁
        lock.lock();
        // 如果仓库存储量不足
        while (list.size() &lt; num){
            System.out.println(&quot;[要消费的产品数量]: &quot;+ num +
                    &quot;\t现库存量: &quot; + list.size() +
                    &quot;\t暂时不能执行消费任务&quot;);
            try{
                // 由于条件不满足，消费阻塞
                empty.await();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        // 消费条件满足情况下，消费num个产品
        for (int i = 1; i &lt;= num; ++i){
            list.remove();
        }
        System.out.println(&quot;[已经消费产品数]: &quot;+ num +
                &quot;\t现库存量: &quot; + list.size());
        // 唤醒其他所有线程
        full.signalAll();
        empty.signalAll();
        // 释放锁
        lock.unlock();
    }
    // set/get方法
    public int getMAX_SIZE() {return MAX_SIZE;}
    public LinkedList&lt;Object&gt; getList() {return list;}
    public void setList(LinkedList&lt;Object&gt; list) {this.list = list;}
}
/**
 * 生产者类Procducer继承线程类Thread
 */
class Producer extends Thread{
    // 每次生产的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Producer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        produce(num);
    }
    // 调用仓库Storage的生产函数
    public void produce(int num){
        storage.produce(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}

/**
 * 消费者类Consumer继承线程类Thread
 */
class Consumer extends Thread{
    // 每次消费的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Consumer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        consume(num);
    }
    // 调用仓库Storage的消费函数
    public void consume(int num){
        storage.consume(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}

public class ProducerConsumerAwaitSignalTest {
    public static void main(String[] args) {
        // 仓库对象
        Storage storage = new Storage();
        // 生产者对象
        Producer p1 = new Producer(storage);
        Producer p2 = new Producer(storage);
        Producer p3 = new Producer(storage);
        Producer p4 = new Producer(storage);
        Producer p5 = new Producer(storage);
        Producer p6 = new Producer(storage);
        Producer p7 = new Producer(storage);
        // 消费者对象
        Consumer c1 = new Consumer(storage);
        Consumer c2 = new Consumer(storage);
        Consumer c3 = new Consumer(storage);
        // 设置生产者产品生产数量
        p1.setNum(10);
        p2.setNum(10);
        p3.setNum(10);
        p4.setNum(10);
        p5.setNum(10);
        p6.setNum(10);
        p7.setNum(80);
        // 设置消费者产品消费数量
        c1.setNum(50);
        c2.setNum(20);
        c3.setNum(30);
        // 线程开始执行
        c1.start();
        c2.start();
        c3.start();
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
        p6.start();
        p7.start();
    }
}
</code></pre>

<p>输出结果<br/>
<img src="media/15179900699305/15179918879176.jpg" alt=""/></p>

<h2 id="toc_2">3. 生产者消费者模型3 ProducerConsumerBlockingQueueTest</h2>

<pre><code class="language-java">package cn.altman.producerconsumer3.test;

/**
 * Created by xuzhihua on 1/8/2018.
 * 生产者消费者模型测试
 * 使用 BlockingQueue阻塞队列方法
 BlockingQueue是JDK5.0的新增内容，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await() / signal()方法。
 它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。
 put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。
 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。 */

import java.util.concurrent.LinkedBlockingQueue;

/**
 * 仓库类Storage实现缓冲区
 */
class Storage{
    // 仓库最大存储量
    private final int MAX_SIZE = 100;
    // 仓库存储的载体
    private LinkedBlockingQueue&lt;Object&gt; list = new LinkedBlockingQueue&lt;Object&gt;(MAX_SIZE);
    // 生产num个产品
    public void produce(int num){
        // 如果仓库剩余容量为0
        if (list.size() == MAX_SIZE){
            System.out.println(&quot;[库存量]: &quot; + MAX_SIZE +
                    &quot;/t暂时不能执行生产任务&quot;);
        }
        // 生产条件满足情况下，生产num个产品
        for (int i = 1; i &lt;= num; ++i){
            try{
                // 放入产品 自动阻塞
                list.put(new Object());
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(&quot;[现仓储量]: &quot; + list.size());
        }
    }
    // 消费num个产品
    public void consume(int num){
        // 如果仓库存储量不足
        if (list.size() == 0){
            System.out.println(&quot;[库存量]: 0&quot; +
                    &quot;\t暂时不能执行消费任务&quot;);
        }
        // 消费条件满足情况下 消费num个产品
        for (int i = 1; i &lt;= num; ++i){
            try{
                // 消费产品 自动阻塞
                list.take();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        System.out.println(&quot;[现仓储量]: &quot; + list.size());
    }
    // set/get 方法
    public int getMAX_SIZE() {return MAX_SIZE;}
    public LinkedBlockingQueue&lt;Object&gt; getList() {return list;}
    public void setList(LinkedBlockingQueue&lt;Object&gt; list) {this.list = list;}
}

/**
 * 生产者类Procducer继承线程类Thread
 */
class Producer extends Thread{
    // 每次生产的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Producer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        produce(num);
    }
    // 调用仓库Storage的生产函数
    public void produce(int num){
        storage.produce(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}

/**
 * 消费者类Consumer继承线程类Thread
 */
class Consumer extends Thread{
    // 每次消费的产品数量
    private int num;
    // 所在放置的仓库
    private Storage storage;
    // 构造函数 设置仓库
    public Consumer(Storage storage){
        this.storage = storage;
    }
    // 线程run函数
    public void run(){
        consume(num);
    }
    // 调用仓库Storage的消费函数
    public void consume(int num){
        storage.consume(num);
    }
    // get/set方法
    public int getNum() {return num;}
    public void setNum(int num) {this.num = num;}
    public Storage getStorage() {return storage;}
    public void setStorage(Storage storage) {this.storage = storage;}
}
public class ProducerConsumerBlockingQueueTest {
    public static void main(String[] args) {
        // 仓库对象
        Storage storage = new Storage();
        // 生产者对象
        Producer p1 = new Producer(storage);
        Producer p2 = new Producer(storage);
        Producer p3 = new Producer(storage);
        Producer p4 = new Producer(storage);
        Producer p5 = new Producer(storage);
        Producer p6 = new Producer(storage);
        Producer p7 = new Producer(storage);
        // 消费者对象
        Consumer c1 = new Consumer(storage);
        Consumer c2 = new Consumer(storage);
        Consumer c3 = new Consumer(storage);
        // 设置生产者产品生产数量
        p1.setNum(10);
        p2.setNum(10);
        p3.setNum(10);
        p4.setNum(10);
        p5.setNum(10);
        p6.setNum(10);
        p7.setNum(80);
        // 设置消费者产品消费数量
        c1.setNum(50);
        c2.setNum(20);
        c3.setNum(30);
        // 线程开始执行
        c1.start();
        c2.start();
        c3.start();
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
        p6.start();
        p7.start();
    }
}
</code></pre>

<p>输出结果<br/>
<img src="media/15179900699305/15179921449601.jpg" alt=""/></p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>