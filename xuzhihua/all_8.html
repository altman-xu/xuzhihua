<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Case.html">Case</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="OS.html">OS</a></li>
						
						  <li id=""><a target="_self" href="Algorithms.html">Algorithms</a></li>
						
						  <li id=""><a target="_self" href="NetWork.html">NetWork</a></li>
						
						  <li id=""><a target="_self" href="Apache.html">Apache</a></li>
						
						  <li id=""><a target="_self" href="Nginx.html">Nginx</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="MySQL.html">MySQL</a></li>
						
						  <li id=""><a target="_self" href="NoSQL.html">NoSQL</a></li>
						
						  <li id=""><a target="_self" href="Mybatis.html">Mybatis</a></li>
						
						  <li id=""><a target="_self" href="JVM.html">JVM</a></li>
						
						  <li id=""><a target="_self" href="Zookeeper.html">Zookeeper</a></li>
						
						  <li id=""><a target="_self" href="MQ.html">MQ</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="Idea.html">Idea</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Shell.html">Shell</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						  <li id=""><a target="_self" href="jdkSource.html">jdkSource</a></li>
						
						  <li id=""><a target="_self" href="Fitness.html">Fitness</a></li>
						
						  <li id=""><a target="_self" href="AboutMe.html">AboutMe</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-03T22:10:05+08:00" itemprop="datePublished">2018/5/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mac.html'>Mac</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15253566058764.html" itemprop="url">
		1</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<pre><code class="language-sequence">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail...
    John--&gt;Alice: Great!
    John-&gt;Bob: How about you?
    Bob--&gt;John: Jolly good!
    
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-03T20:19:02+08:00" itemprop="datePublished">2018/5/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='NoSQL.html'>NoSQL</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15253499429210.html" itemprop="url">
		redis底层数据结构</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p>摘自 《Redis设计与实现》<br/>
使用的redis源码是 redis3.0</p>
</blockquote>



			 
			<a href="15253499429210.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-04-27T15:57:53+08:00" itemprop="datePublished">2018/4/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Shell.html'>Shell</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15248158738894.html" itemprop="url">
		Linux中的三剑客之grep</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p><a href="http://www.zsythink.net/archives/1733">grep命令详解</a></p>
</blockquote>

<!--more-->

<ul>
<li>
<a href="#toc_0">grep简介</a>
</li>
<li>
<a href="#toc_1">grep man</a>
</li>
</ul>


<h2 id="toc_0">grep简介</h2>

<p>Linux中的三剑客: grep sed awk <br/>
grep全程: Global search Regular Expression and Print out the line</p>

<h2 id="toc_1">grep man</h2>

<pre><code>GREP(1)                   BSD General Commands Manual                  GREP(1)

NAME
     grep, egrep, fgrep, zgrep, zegrep, zfgrep -- file pattern searcher

SYNOPSIS
     grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]] [-e pattern] [-f file] [--binary-files=value] [--color[=when]] [--colour[=when]]
          [--context[=num]] [--label] [--line-buffered] [--null] [pattern] [file ...]

DESCRIPTION
     The grep utility searches any given input files, selecting lines that match one or more patterns.  By default, a pattern matches an input line if the
     regular expression (RE) in the pattern matches the input line without its trailing newline.  An empty expression matches every line.  Each input line
     that matches at least one of the patterns is written to the standard output.

     grep is used for simple patterns and basic regular expressions (BREs); egrep can handle extended regular expressions (EREs).  See re_format(7) for
     more information on regular expressions.  fgrep is quicker than both grep and egrep, but can only handle fixed patterns (i.e. it does not interpret
     regular expressions).  Patterns may consist of one or more lines, allowing any of the pattern lines to match a portion of the input.

     zgrep, zegrep, and zfgrep act like grep, egrep, and fgrep, respectively, but accept input files compressed with the compress(1) or gzip(1) compression
     utilities.

     The following options are available:

     -A num, --after-context=num
             Print num lines of trailing context after each match.  See also the -B and -C options.

     -a, --text
             Treat all files as ASCII text.  Normally grep will simply print ``Binary file ... matches&#39;&#39; if files contain binary characters.  Use of this
             option forces grep to output lines matching the specified pattern.

     -B num, --before-context=num
             Print num lines of leading context before each match.  See also the -A and -C options.

     -b, --byte-offset
             The offset in bytes of a matched pattern is displayed in front of the respective matched line.

     -C[num, --context=num]
             Print num lines of leading and trailing context surrounding each match.  The default is 2 and is equivalent to -A 2 -B 2.  Note: no whitespace
             may be given between the option and its argument.

     -c, --count
             Only a count of selected lines is written to standard output.

     --colour=[when, --color=[when]]
             Mark up the matching text with the expression stored in GREP_COLOR environment variable.  The possible values of when can be `never&#39;, `always&#39;
             or `auto&#39;.

     -D action, --devices=action
             Specify the demanded action for devices, FIFOs and sockets.  The default action is `read&#39;, which means, that they are read as if they were
             normal files.  If the action is set to `skip&#39;, devices will be silently skipped.

     -d action, --directories=action
             Specify the demanded action for directories.  It is `read&#39; by default, which means that the directories are read in the same manner as normal
             files.  Other possible values are `skip&#39; to silently ignore the directories, and `recurse&#39; to read them recursively, which has the same effect
             as the -R and -r option.

     -E, --extended-regexp
             Interpret pattern as an extended regular expression (i.e. force grep to behave as egrep).

     -e pattern, --regexp=pattern
             Specify a pattern used during the search of the input: an input line is selected if it matches any of the specified patterns.  This option is
             most useful when multiple -e options are used to specify multiple patterns, or when a pattern begins with a dash (`-&#39;).

     --exclude
             If specified, it excludes files matching the given filename pattern from the search.  Note that --exclude patterns take priority over
             --include patterns, and if no --include pattern is specified, all files are searched that are not excluded.  Patterns are matched to the full
             path specified, not only to the filename component.

     --exclude-dir
             If -R is specified, it excludes directories matching the given filename pattern from the search.  Note that --exclude-dir patterns take prior-
             ity over --include-dir patterns, and if no --include-dir pattern is specified, all directories are searched that are not excluded.

     -F, --fixed-strings
             Interpret pattern as a set of fixed strings (i.e. force grep to behave as fgrep).

     -f file, --file=file
             Read one or more newline separated patterns from file.  Empty pattern lines match every input line.  Newlines are not considered part of a
             pattern.  If file is empty, nothing is matched.

     -G, --basic-regexp
             Interpret pattern as a basic regular expression (i.e. force grep to behave as traditional grep).

     -H      Always print filename headers with output lines.

     -h, --no-filename
             Never print filename headers (i.e. filenames) with output lines.

     --help  Print a brief help message.

     -I      Ignore binary files.  This option is equivalent to --binary-file=without-match option.

     -i, --ignore-case
             Perform case insensitive matching.  By default, grep is case sensitive.

     --include
             If specified, only files matching the given filename pattern are searched.  Note that --exclude patterns take priority over --include pat-
             terns.  Patterns are matched to the full path specified, not only to the filename component.

     --include-dir
             If -R is specified, only directories matching the given filename pattern are searched.  Note that --exclude-dir patterns take priority over
             --include-dir patterns.

     -J, --bz2decompress
             Decompress the bzip2(1) compressed file before looking for the text.

     -L, --files-without-match
             Only the names of files not containing selected lines are written to standard output.  Pathnames are listed once per file searched.  If the
             standard input is searched, the string ``(standard input)&#39;&#39; is written.

     -l, --files-with-matches
             Only the names of files containing selected lines are written to standard output.  grep will only search a file until a match has been found,
             making searches potentially less expensive.  Pathnames are listed once per file searched.  If the standard input is searched, the string
             ``(standard input)&#39;&#39; is written.

     --mmap  Use mmap(2) instead of read(2) to read input, which can result in better performance under some circumstances but can cause undefined behav-
             iour.

     -m num, --max-count=num
             Stop reading the file after num matches.

     -n, --line-number
             Each output line is preceded by its relative line number in the file, starting at line 1.  The line number counter is reset for each file pro-
             cessed.  This option is ignored if -c, -L, -l, or -q is specified.

     --null  Prints a zero-byte after the file name.

     -O      If -R is specified, follow symbolic links only if they were explicitly listed on the command line.  The default is not to follow symbolic
             links.

     -o, --only-matching
             Prints only the matching part of the lines.

     -p      If -R is specified, no symbolic links are followed.  This is the default.

     -q, --quiet, --silent
             Quiet mode: suppress normal output.  grep will only search a file until a match has been found, making searches potentially less expensive.

     -R, -r, --recursive
             Recursively search subdirectories listed.

     -S      If -R is specified, all symbolic links are followed.  The default is not to follow symbolic links.

     -s, --no-messages
             Silent mode.  Nonexistent and unreadable files are ignored (i.e. their error messages are suppressed).

     -U, --binary
             Search binary files, but do not attempt to print them.

     -V, --version
             Display version information and exit.

     -v, --invert-match
             Selected lines are those not matching any of the specified patterns.

     -w, --word-regexp
             The expression is searched for as a word (as if surrounded by `[[:&lt;:]]&#39; and `[[:&gt;:]]&#39;; see re_format(7)).

     -x, --line-regexp
             Only input lines selected against an entire fixed string or regular expression are considered to be matching lines.

     -y      Equivalent to -i.  Obsoleted.

     -Z, -z, --decompress
             Force grep to behave as zgrep.

     --binary-files=value
             Controls searching and printing of binary files.  Options are binary, the default: search binary files but do not print them; without-match:
             do not search binary files; and text: treat all files as text.

     --context[=num]
             Print num lines of leading and trailing context.  The default is 2.

     --line-buffered
             Force output to be line buffered.  By default, output is line buffered when standard output is a terminal and block buffered otherwise.

     If no file arguments are specified, the standard input is used.

ENVIRONMENT
     GREP_OPTIONS  May be used to specify default options that will be placed at the beginning of the argument list.  Backslash-escaping is not supported,
                   unlike the behavior in GNU grep.

EXIT STATUS
     The grep utility exits with one of the following values:

     0     One or more lines were selected.
     1     No lines were selected.
     &gt;1    An error occurred.

EXAMPLES
     To find all occurrences of the word `patricia&#39; in a file:

           $ grep &#39;patricia&#39; myfile

     To find all occurrences of the pattern `.Pp&#39; at the beginning of a line:

           $ grep &#39;^\.Pp&#39; myfile

     The apostrophes ensure the entire expression is evaluated by grep instead of by the user&#39;s shell.  The caret `^&#39; matches the null string at the begin-
     ning of a line, and the `\&#39; escapes the `.&#39;, which would otherwise match any character.

     To find all lines in a file which do not contain the words `foo&#39; or `bar&#39;:

           $ grep -v -e &#39;foo&#39; -e &#39;bar&#39; myfile

     A simple example of an extended regular expression:

           $ egrep &#39;19|20|25&#39; calendar

     Peruses the file `calendar&#39; looking for either 19, 20, or 25.

SEE ALSO
     ed(1), ex(1), gzip(1), sed(1), re_format(7)

STANDARDS
     The grep utility is compliant with the IEEE Std 1003.1-2008 (``POSIX.1&#39;&#39;) specification.

     The flags [-AaBbCDdGHhIJLmoPRSUVwZ] are extensions to that specification, and the behaviour of the -f flag when used with an empty pattern file is
     left undefined.

     All long options are provided for compatibility with GNU versions of this utility.

     Historic versions of the grep utility also supported the flags [-ruy].  This implementation supports those options; however, their use is strongly
     discouraged.

HISTORY
     The grep command first appeared in Version 6 AT&amp;T UNIX.

BUGS
     The grep utility does not normalize Unicode input, so a pattern containing composed characters will not match decomposed input, and vice versa.

BSD                              July 28, 2010                             BSD

</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-04-19T09:40:24+08:00" itemprop="datePublished">2018/4/19</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Shell.html'>Shell</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15241020246672.html" itemprop="url">
		Linux中的三剑客之awk命令</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><a href="https://www.cnblogs.com/quincyhu/p/5884390.html">shell编程之awk命令详解</a><br/>
<a href="http://www.zsythink.net/archives/tag/awk/">awk从入门到放弃</a></p>

<h2 id="toc_0">awk 去重 重复的数据只保留一条</h2>

<pre><code class="language-zsh">##去重，重复的数据只保留一条
##1. 内容输出到终端 (以下两个效果一样)
cat test.sql | awk &#39;!a[$0]++{print}&#39;
cat test.sql | awk &#39;!a[$1]++{print}&#39;
##2. 内容输出到文件
awk &#39;!a[$0]++&#39; test.sql &gt;&gt; test-1.sql
</code></pre>

<h2 id="toc_1">awk 去重 只显示重复行</h2>

<pre><code class="language-zsh">##去重，只显示重复行
##1. 内容输出到终端
cat test.sql| awk &#39;a[$0]++{print}&#39;
##2. 内容输出到文件
awk &#39;a[$0]++&#39; test.sql &gt;&gt; test-2.sql
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-04-19T08:58:14+08:00" itemprop="datePublished">2018/4/19</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Shell.html'>Shell</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15240994943835.html" itemprop="url">
		shell基础学习</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p><a href="http://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>
</blockquote>

<!--more-->

<ul>
<li>
<a href="#toc_0">运行</a>
</li>
<li>
<a href="#toc_1">注释</a>
</li>
<li>
<a href="#toc_2">变量</a>
<ul>
<li>
<a href="#toc_3">定义变量</a>
</li>
<li>
<a href="#toc_4">只读变量</a>
</li>
<li>
<a href="#toc_5">删除变量</a>
</li>
<li>
<a href="#toc_6">变量类型</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">字符串</a>
<ul>
<li>
<a href="#toc_8">单引号</a>
</li>
<li>
<a href="#toc_10">拼接字符串</a>
</li>
<li>
<a href="#toc_11">获取字符串长度</a>
</li>
<li>
<a href="#toc_12">提取子字符串</a>
</li>
<li>
<a href="#toc_13">查找子字符串</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">数组</a>
<ul>
<li>
<a href="#toc_15">定义数组</a>
</li>
<li>
<a href="#toc_16">读取数组</a>
</li>
<li>
<a href="#toc_17">数组长度</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">传递参数</a>
</li>
<li>
<a href="#toc_19">运算符</a>
<ul>
<li>
<a href="#toc_20">算术运算符</a>
</li>
<li>
<a href="#toc_21">关系运算符</a>
</li>
<li>
<a href="#toc_22">布尔运算符</a>
</li>
<li>
<a href="#toc_23">逻辑运算符</a>
</li>
<li>
<a href="#toc_24">字符串运算符</a>
</li>
<li>
<a href="#toc_25">文件测试运算符</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">echo 命令</a>
</li>
<li>
<a href="#toc_27">printf 命令</a>
</li>
<li>
<a href="#toc_28">test 命令</a>
<ul>
<li>
<a href="#toc_29">数值测试</a>
</li>
<li>
<a href="#toc_30">字符串测试</a>
</li>
<li>
<a href="#toc_31">文件测试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_32">非 与 或</a>
</li>
<li>
<a href="#toc_33">流程控制</a>
<ul>
<li>
<a href="#toc_34">if else if</a>
</li>
<li>
<a href="#toc_35">for循环</a>
</li>
<li>
<a href="#toc_36">while 语句</a>
</li>
<li>
<a href="#toc_37">无限循环</a>
</li>
<li>
<a href="#toc_38">until循环</a>
</li>
<li>
<a href="#toc_39">case</a>
</li>
<li>
<a href="#toc_40">跳出循环</a>
<ul>
<li>
<a href="#toc_41">break命令</a>
</li>
<li>
<a href="#toc_42">continue</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_43">函数</a>
</li>
<li>
<a href="#toc_44">Shell 输入/输出重定向</a>
<ul>
<li>
<a href="#toc_45">/dev/null 文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">Shell 文件包含</a>
</li>
</ul>


<h2 id="toc_0">运行</h2>

<blockquote>
<p>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p>
</blockquote>

<pre><code class="language-shell">#!/bin/bash
echo &quot;Hello World !&quot;
</code></pre>

<p>运行方法:(上面的代码保存为 test.sh，并 cd 到相应目录)</p>

<ol>
<li><p>作为可执行程序</p>

<pre><code class="language-zsh">chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
</code></pre></li>
<li><p>作为解释器参数</p>

<pre><code class="language-zsh">/bin/sh test.sh
/bin/php test.php
</code></pre></li>
</ol>

<h2 id="toc_1">注释</h2>

<p>以&quot;#&quot;开头的行就是注释，会被解释器忽略。<br/>
sh里没有多行注释，只能每一行加一个#号<br/>
多行注释 变通方法</p>

<blockquote>
<p>将这些多行定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
</blockquote>

<h2 id="toc_2">变量</h2>

<h3 id="toc_3">定义变量</h3>

<pre><code class="language-zsh">your_name=&quot;qinjx&quot;
#变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界
#建议都加 花括号
echo $your_name
echo ${your_name}

for file in `ls /etc`
#或
for file in $(ls /etc)
</code></pre>

<h3 id="toc_4">只读变量</h3>

<pre><code class="language-zsh">myUrl=&quot;http://www.w3cschool.cc&quot;
readonly myUrl
#下面这句会报错
myUrl=&quot;http://www.runoob.com&quot;
</code></pre>

<h3 id="toc_5">删除变量</h3>

<pre><code class="language-zsh">unset variable_name
#变量被删除后不能再次使用。unset 命令不能删除只读变量。
myUrl=&quot;http://www.runoob.com&quot;
unset myUrl
#下面这个echo没任何输出
echo $myUrl
</code></pre>

<h3 id="toc_6">变量类型</h3>

<ol>
<li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>

<h2 id="toc_7">字符串</h2>

<p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号</p>

<h3 id="toc_8">单引号</h3>

<p>单引号字符串的限制：</p>

<ol>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>

<h3 id="toc_9">双引号</h3>

<p>双引号的优点：</p></li>
<li><p>双引号里可以有变量</p></li>
<li><p>双引号里可以出现转义字符</p></li>
</ol>

<h3 id="toc_10">拼接字符串</h3>

<pre><code class="language-zsh">your_name=&quot;qinjx&quot;
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting $greeting_1
</code></pre>

<h3 id="toc_11">获取字符串长度</h3>

<pre><code class="language-zsh">string=&quot;abcd&quot;
echo ${#string} #输出 4
</code></pre>

<h3 id="toc_12">提取子字符串</h3>

<pre><code class="language-zsh">string=&quot;runoob is a great site&quot;
echo ${string:1:4} # 输出 unoo ##从字符串第 2 个字符开始截取 4 个字符
</code></pre>

<h3 id="toc_13">查找子字符串</h3>

<pre><code class="language-zsh">string=&quot;runoob is a great company&quot;
echo `expr index &quot;$string&quot; is`  # 输出 8
</code></pre>

<h2 id="toc_14">数组</h2>

<h3 id="toc_15">定义数组</h3>

<p>在Shell中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。定义数组的一般形式为：<br/>
数组名=(值1 值2 ... 值n)</p>

<pre><code class="language-zsh">array_name=(value0 value1 value2 value3)
#或
array_name=(
value0
value1
value2
value3
)
#或 单独定义数组的各个分量：
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
</code></pre>

<h3 id="toc_16">读取数组</h3>

<p>${数组名[下标]}</p>

<pre><code class="language-zsh">valuen=${array_name[n]}
#使用@符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}
</code></pre>

<h3 id="toc_17">数组长度</h3>

<p>获取数组长度的方法与获取字符串长度的方法相同</p>

<pre><code class="language-zsh"># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
</code></pre>

<h2 id="toc_18">传递参数</h2>

<p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>

<pre><code class="language-zsh">echo &quot;Shell 传递参数实例！&quot;;
echo &quot;执行的文件名：$0&quot;;
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
##################################执行输出
$ chmod +x test.sh 
$ ./test.sh 1 2 3
#Shell 传递参数实例！
#执行的文件名：./test.sh
#第一个参数为：1
#第二个参数为：2
#第三个参数为：3
</code></pre>

<table class="reference"> <tbody> <tr> <th> 参数处理</th> <th> 说明</th> </tr> <tr> <td> $#</td> <td> 传递到脚本的参数个数</td> </tr> <tr> <td> $*</td> <td> 以一个单字符串显示所有向脚本传递的参数。<br>
如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</td> </tr> <tr> <td> $$</td> <td> 脚本运行的当前进程ID号</td> </tr> <tr> <td> $!</td> <td> 后台运行的最后一个进程的ID号</td> </tr> <tr> <td> $@</td> <td> 与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>

如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 
</td> </tr> <tr> <td> $-</td> <td> 显示Shell使用的当前选项，与<a href="/linux/linux-comm-set.html" target="_blank">set命令</a>功能相同。</td> </tr> <tr> <td> $?</td> <td> 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td> </tr> </tbody> </table>

<p>$* 与 $@ 区别：</p>

<p>相同点：都是引用所有参数。<br/>
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。</p>

<pre><code class="language-zsh">echo &quot;-- \$* 演示 ---&quot;
for i in &quot;$*&quot;; do
    echo $i
done

echo &quot;-- \$@ 演示 ---&quot;
for i in &quot;$@&quot;; do
    echo $i
done
##################################执行输出
$ chmod +x test.sh 
$ ./test.sh 1 2 3
#-- $* 演示 ---
#1 2 3
#-- $@ 演示 ---
#1
#2
#3
</code></pre>

<h2 id="toc_19">运算符</h2>

<h3 id="toc_20">算术运算符</h3>

<pre><code class="language-zsh">#!/bin/bash

val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
val=`expr $a \* $b`
echo &quot;a * b : $val&quot;
</code></pre>

<p>注意点：</p>

<ol>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
</ol>

<table class="reference">

    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                +</td>
            <td>
                加法</td>
            <td>
                `expr $a + $b` 结果为&nbsp;30。</td>
        </tr>
        <tr>
            <td>
                -</td>
            <td>
                减法</td>
            <td>
                `expr $a - $b` 结果为 -10。</td>
        </tr>
        <tr>
            <td>
                *</td>
            <td>
                乘法</td>
            <td>
                `expr $a \* $b` 结果为 &nbsp;200。</td>
        </tr>
        <tr>
            <td>
                /</td>
            <td>
                除法</td>
            <td>
                `expr $b / $a` 结果为&nbsp;2。</td>
        </tr>
        <tr>
            <td>
                %</td>
            <td>
                取余</td>
            <td>
                `expr $b % $a` 结果为&nbsp;0。</td>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                赋值</td>
            <td>
                a=$b 将把变量 b 的值赋给 a。</td>
        </tr>
        <tr>
            <td>
                ==</td>
            <td>
                相等。用于比较两个数字，相同则返回 true。</td>
            <td>
                [ $a == $b ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                不相等。用于比较两个数字，不相同则返回 true。</td>
            <td>
                [ $a != $b ] 返回 true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

val=`expr $a + $b`
echo &quot;a + b : $val&quot;

val=`expr $a - $b`
echo &quot;a - b : $val&quot;

val=`expr $a \* $b`
echo &quot;a * b : $val&quot;

val=`expr $b / $a`
echo &quot;b / a : $val&quot;

val=`expr $b % $a`
echo &quot;b % a : $val&quot;

if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;a 不等于 b&quot;
fi
</code></pre>

<h3 id="toc_21">关系运算符</h3>

<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br/>
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                -eq</td>
            <td>
                检测两个数是否相等，相等返回 true。</td>
            <td>
                [ $a -eq $b ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -ne</td>
            <td>
                检测两个数是否相等，不相等返回 true。</td>
            <td>
                [ $a -ne $b ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -gt</td>
            <td>
                检测左边的数是否大于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -gt $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -lt</td>
            <td>
                检测左边的数是否小于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -lt $b ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -ge</td>
            <td>
                检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -ge $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -le</td>
            <td>
                检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -le $b ] 返回 true。</td>
        </tr>
    </tbody>
</table>

<pre><code>a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>

<h3 id="toc_22">布尔运算符</h3>

<p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                !</td>
            <td>
                非运算，表达式为 true 则返回 false，否则返回 true。</td>
            <td>
                [ ! false ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -o</td>
            <td>
                或运算，有一个表达式为 true 则返回 true。</td>
            <td>
                [ $a -lt 20 -o $b -gt 100 ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -a</td>
            <td>
                与运算，两个表达式都为 true 才返回 true。</td>
            <td>
                [ $a -lt 20 -a $b -gt 100 ] 返回&nbsp;false。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>

<h3 id="toc_23">逻辑运算符</h3>

<p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                &amp;&amp;  </td>
            <td>
                逻辑的 AND </td>
            <td>
                [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
        </tr>
        <tr>
            <td>
                ||</td>
            <td>
                逻辑的 OR</td>
            <td>
                [[ $a -lt 100 || $b -gt 100 ]] 返回 true</td>
        </tr>
        
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>

<h3 id="toc_24">字符串运算符</h3>

<p>下表列出了常用的字符串运算符，假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                检测两个字符串是否相等，相等返回 true。</td>
            <td>
                [ $a = $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                检测两个字符串是否相等，不相等返回 true。</td>
            <td>
                [ $a != $b ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -z</td>
            <td>
                检测字符串长度是否为0，为0返回 true。</td>
            <td>
                [ -z $a ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -n</td>
            <td>
                检测字符串长度是否为0，不为0返回 true。</td>
            <td>
                [ -n $a ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                str</td>
            <td>
                检测字符串是否为空，不为空返回 true。</td>
            <td>
                [ $a ] 返回&nbsp;true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a = $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n $a ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>

<h3 id="toc_25">文件测试运算符</h3>

<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                操作符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                -b file</td>
            <td>
                检测文件是否是块设备文件，如果是，则返回 true。</td>
            <td>
                [ -b $file ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -c file</td>
            <td>
                检测文件是否是字符设备文件，如果是，则返回 true。</td>
            <td>
                [ -c $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -d file</td>
            <td>
                检测文件是否是目录，如果是，则返回 true。</td>
            <td>
                [ -d $file ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -f file</td>
            <td>
                检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
            <td>
                [ -f $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -g file</td>
            <td>
                检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
            <td>
                [ -g $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -k file</td>
            <td>
                检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
            <td>
                [ -k $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -p file</td>
            <td>
                检测文件是否是有名管道，如果是，则返回 true。</td>
            <td>
                [ -p $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -u file</td>
            <td>
                检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
            <td>
                [ -u $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -r file</td>
            <td>
                检测文件是否可读，如果是，则返回 true。</td>
            <td>
                [ -r $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -w file</td>
            <td>
                检测文件是否可写，如果是，则返回 true。</td>
            <td>
                [ -w $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -x file</td>
            <td>
                检测文件是否可执行，如果是，则返回 true。</td>
            <td>
                [ -x $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -s file</td>
            <td>
                检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
            <td>
                [ -s $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -e file</td>
            <td>
                检测文件（包括目录）是否存在，如果是，则返回 true。</td>
            <td>
                [ -e $file ] 返回&nbsp;true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">file=&quot;/var/www/runoob/test.sh&quot;
if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>

<h2 id="toc_26">echo 命令</h2>

<p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出<br/>
命令格式：<br/>
echo string</p>

<pre><code class="language-zsh">echo &quot;It is a test&quot;
#等价
echo It is a test

#显示转义字符
echo &quot;\&quot;It is a test\&quot;&quot;
#等价
echo \&quot;It is a test\&quot;

#显示变量
#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
read name 
echo &quot;$name It is a test&quot;

#显示换行
echo -e &quot;OK! \n&quot; # -e 开启转义
echo &quot;It it a test&quot;

#显示不换行
echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行
echo &quot;It is a test&quot;

#显示结果定向至文件
echo &quot;It is a test&quot; &gt; myfile

#原样输出字符串，不进行转义或取变量(用单引号)
echo &#39;$name\&quot;&#39;

#显示命令执行结果
echo `date`
</code></pre>

<h2 id="toc_27">printf 命令</h2>

<p>printf 命令模仿 C 程序库（library）里的 printf() 程序。<br/>
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。<br/>
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p>

<p>printf 命令的语法：<br/>
printf  format-string  [arguments...]</p>

<p>printf的转义序列<br/>
<table class="reference"><tbody><tr><th><br/>
序列</th><th>说明</th></tr><tr><td><br/>
\a</td><td>警告字符，通常为ASCII的BEL字符</td></tr><tr><td><br/>
\b</td><td>后退</td></tr><tr><td><br/>
\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><br/>
\f</td><td>换页（formfeed）</td></tr><tr><td><br/>
\n </td><td>换行</td></tr><tr><td><br/>
\r</td><td>回车（Carriage return）</td></tr><tr><td><br/>
\t</td><td>水平制表符</td></tr><tr><td><br/>
\v</td><td>垂直制表符</td></tr><tr><td><br/>
\</td><td>一个字面上的反斜杠字符</td></tr><tr><td><br/>
\ddd </td><td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><br/>
\0ddd</td><td>表示1到3位的八进制值字符</td></tr></tbody></table></p>

<pre><code class="language-zsh">echo &quot;Hello, Shell&quot;
printf &quot;Hello, Shell\n&quot;

printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;
# 单引号与双引号效果一样 
printf &#39;%d %s\n&#39; 1 &quot;abc&quot; 
# 没有引号也可以输出
printf %s abcdef
# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def
printf &quot;%s\n&quot; abc def
printf &quot;%s %s %s\n&quot; a b c d e f g h i j
# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 


##################################
%d %s %c %f 格式替代符详解:
d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！
s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！
c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！
f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！
如：其中最后一个参数是 &quot;def&quot;，%c 自动截取字符串的第一个字符作为结果输出。
</code></pre>

<h2 id="toc_28">test 命令</h2>

<p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>

<h3 id="toc_29">数值测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                -eq</td>
            <td>
                等于则为真</td>
        </tr>
        <tr>
            <td>
                -ne</td>
            <td>
                不等于则为真</td>
        </tr>
        <tr>
            <td>
                -gt</td>
            <td>
                大于则为真</td>
        </tr>
        <tr>
            <td>
                -ge</td>
            <td>
                大于等于则为真</td>
        </tr>
        <tr>
            <td>
                -lt</td>
            <td>
                小于则为真</td>
        </tr>
        <tr>
            <td>
                -le</td>
            <td>
                小于等于则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo &#39;两个数相等！&#39;
else
    echo &#39;两个数不相等！&#39;
fi

result=$[num1+num2] # 注意等号两边不能有空格
echo &quot;result 为： $result&quot;
</code></pre>

<h3 id="toc_30">字符串测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                等于则为真</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                不相等则为真</td>
        </tr>
        <tr>
            <td>
                -z 字符串</td>
            <td>
                字符串的长度为零则为真</td>
        </tr>
        <tr>
            <td>
                -n 字符串</td>
            <td>
                字符串的长度不为零则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">num1=&quot;ru1noob&quot;
num2=&quot;runoob&quot;
if test $num1 = $num2
then
    echo &#39;两个字符串相等!&#39;
else
    echo &#39;两个字符串不相等!&#39;
fi
</code></pre>

<h3 id="toc_31">文件测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                -e 文件名</td>
            <td>
                如果文件存在则为真</td>
        </tr>
        <tr>
            <td>
                -r 文件名</td>
            <td>
                如果文件存在且可读则为真</td>
        </tr>
        <tr>
            <td>
                -w 文件名</td>
            <td>
                如果文件存在且可写则为真</td>
        </tr>
        <tr>
            <td>
                -x 文件名</td>
            <td>
                如果文件存在且可执行则为真</td>
        </tr>
        <tr>
            <td>
                -s 文件名</td>
            <td>
                如果文件存在且至少有一个字符则为真</td>
        </tr>
        <tr>
            <td>
                -d 文件名</td>
            <td>
                如果文件存在且为目录则为真</td>
        </tr>
        <tr>
            <td>
                -f 文件名</td>
            <td>
                如果文件存在且为普通文件则为真</td>
        </tr>
        <tr>
            <td>
                -c 文件名</td>
            <td>
                如果文件存在且为字符型特殊文件则为真</td>
        </tr>
        <tr>
            <td>
                -b 文件名</td>
            <td>
                如果文件存在且为块特殊文件则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">cd /bin
if test -e ./bash
then
    echo &#39;文件已存在!&#39;
else
    echo &#39;文件不存在!&#39;
fi
</code></pre>

<h2 id="toc_32">非 与 或</h2>

<p>另外，Shell还提供了 非( ! )、与( -a )、或( -o ) 三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：</p>

<pre><code class="language-zsh">cd /bin
if test -e ./notFile -o -e ./bash
then
    echo &#39;至少有一个文件存在!&#39;
else
    echo &#39;两个文件都不存在&#39;
fi
</code></pre>

<h2 id="toc_33">流程控制</h2>

<h3 id="toc_34">if else if</h3>

<p>在sh/bash里，如果else分支没有语句执行，就不要写这个else</p>

<pre><code class="language-zsh">#语法
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
#写成一行
if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi

#if else语句经常与test命令结合使用，如下所示：
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo &#39;两个数字相等!&#39;
else
    echo &#39;两个数字不相等!&#39;
fi
</code></pre>

<h3 id="toc_35">for循环</h3>

<pre><code class="language-zsh">#语法
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done

#写成一行
for var in item1 item2 ... itemN; do command1; command2… done;

for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done
for str in &#39;This is a string&#39;
do
    echo $str
done
</code></pre>

<h3 id="toc_36">while 语句</h3>

<p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件<br/>
<a href="http://www.runoob.com/linux/linux-comm-let.html">Bash let 命令</a></p>

<pre><code class="language-zsh">#语法
while condition
do
    command
done



int=1
while(( $int&lt;=5 ))
do
    echo $int
    #使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量 
    let &quot;int++&quot;
done

echo &#39;按下 &lt;CTRL-D&gt; 退出&#39;
echo -n &#39;输入你最喜欢的网站名: &#39;
while read FILM
do
    echo &quot;是的！$FILM 是一个好网站&quot;
done

</code></pre>

<h3 id="toc_37">无限循环</h3>

<pre><code class="language-zsh">while :
do
    command
done
#或
while true
do
    command
done
#或
for (( ; ; ))
</code></pre>

<h3 id="toc_38">until循环</h3>

<p>until 循环执行一系列命令直至条件为 true 时停止。<br/>
until 循环与 while 循环在处理方式上刚好相反。<br/>
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>

<pre><code class="language-zsh">#语法
until condition
do
    command
done

a=0
until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
</code></pre>

<h3 id="toc_39">case</h3>

<p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令</p>

<pre><code class="language-zsh">#语法
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac

echo &#39;输入 1 到 4 之间的数字:&#39;
echo &#39;你输入的数字为:&#39;
read aNum
case $aNum in
    1)  echo &#39;你选择了 1&#39;
    ;;
    2)  echo &#39;你选择了 2&#39;
    ;;
    3)  echo &#39;你选择了 3&#39;
    ;;
    4)  echo &#39;你选择了 4&#39;
    ;;
    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;
    ;;
esac
</code></pre>

<h3 id="toc_40">跳出循环</h3>

<h4 id="toc_41">break命令</h4>

<p>break命令允许跳出所有循环（终止执行后面的所有循环）</p>

<pre><code class="language-zsh">while :
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done
</code></pre>

<h4 id="toc_42">continue</h4>

<p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>

<pre><code class="language-zsh">while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
    #esaccase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。
done
</code></pre>

<h2 id="toc_43">函数</h2>

<pre><code class="language-zsh">#定义函数语法
#1. 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
#2. 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)
[ function ] funname [()]

{

    action;

    [return int;]

}



demoFun(){
    echo &quot;这是我的第一个 shell 函数!&quot;
}
echo &quot;-----函数开始执行-----&quot;
demoFun
echo &quot;-----函数执行完毕-----&quot;


funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;


#函数参数  在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值
#注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。
funWithParam(){
    echo &quot;第一个参数为 $1 !&quot;
    echo &quot;第二个参数为 $2 !&quot;
    echo &quot;第十个参数为 $10 !&quot;
    echo &quot;第十个参数为 ${10} !&quot;
    echo &quot;第十一个参数为 ${11} !&quot;
    echo &quot;参数总数有 $# 个!&quot;
    echo &quot;作为一个字符串输出所有参数 $* !&quot;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
</code></pre>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数处理</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                $#</td>
            <td>
                传递到脚本的参数个数</td>
        </tr>
        <tr>
            <td>
                $*</td>
            <td>
                以一个单字符串显示所有向脚本传递的参数</td>
        </tr>
        <tr>
            <td>
                $$</td>
            <td>
                脚本运行的当前进程ID号</td>
        </tr>
        <tr>
            <td>
                $!</td>
            <td>
                后台运行的最后一个进程的ID号</td>
        </tr>
        <tr>
            <td>
                $@</td>
            <td>
                与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
        </tr>
        <tr>
            <td>
                $-</td>
            <td>
                显示Shell使用的当前选项，与set命令功能相同。</td>
        </tr>
        <tr>
            <td>
                $?</td>
            <td>
                显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
        </tr>
    </tbody>
</table>

<h2 id="toc_44">Shell 输入/输出重定向</h2>

<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th style="width:129px;">
                命令</th>
            <th style="width:409px;">
                说明</th>
        </tr>
        <tr>
            <td>
                command &gt; file</td>
            <td>
                将输出重定向到 file。</td>
        </tr>
        <tr>
            <td>
                command &lt; file</td>
            <td>
                将输入重定向到 file。</td>
        </tr>
        <tr>
            <td>
                command &gt;&gt; file</td>
            <td>
                将输出以追加的方式重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt; file</td>
            <td>
                将文件描述符为 n 的文件重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt;&gt; file</td>
            <td>
                将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt;&amp; m</td>
            <td>
                将输出文件 m 和 n 合并。</td>
        </tr>
        <tr>
            <td>
                n &lt;&amp; m</td>
            <td>
                将输入文件 m 和 n 合并。</td>
        </tr>
        <tr>
            <td>
                &lt;&lt; tag</td>
            <td>
                将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">#输出重定向 语法
command1 &gt; file1

#######################
who &gt; users      #重定向会覆盖文件内容
who &gt;&gt; users     #不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾
cat users


#输入重定向 语法
command1 &lt; file1

#######################
wc -l users         #会输出文件名

wc -l &lt; users       #不会输出文件名 因为它仅仅知道从标准输入读取内容
</code></pre>

<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。<br/>
如果希望 stderr 重定向到 file，可以这样写：<br/>
<code>command 2 &gt; file</code><br/>
如果希望 stderr 追加到 file 文件末尾，可以这样写：<br/>
<code>command 2 &gt;&gt; file</code>  </p>

<p><strong>2 表示标准错误文件(stderr)</strong></p>

<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：<br/>
<code>command &gt; file 2&gt;&amp;1</code>或者<code>command &gt;&gt; file 2&gt;&amp;1</code></p>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：<br/>
<code>command &lt; file1 &gt;file</code><br/>
command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>

<pre><code class="language-zsh">#Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序 语法：
command &lt;&lt; delimiter
    document
delimiter

#它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。
#结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
#开始的delimiter前后的空格会被忽略掉。

wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

cat &lt;&lt; EOF
欢迎来到
菜鸟教程
www.runoob.com
EOF
</code></pre>

<pre><code class="language-zsh">## 他人笔记
command &gt; file 2&gt;&amp;1
$ command &gt;&gt; file 2&gt;&amp;1
这里的&amp;没有固定的意思

放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符，内置的文件描述符如下

1 =&gt; stdout
2 =&gt; stderr
0 =&gt; stdin
换言之 2&gt;1 代表将stderr重定向到当前路径下文件名为1的regular file中，而2&gt;&amp;1代表将stderr重定向到文件描述符为1的文件(即/dev/stdout)中，这个文件就是stdout在file system中的映射

而&amp;&gt;file是一种特殊的用法，也可以写成&gt;&amp;file，二者的意思完全相同，都等价于

&gt;file 2&gt;&amp;1
此处&amp;&gt;或者&gt;&amp;视作整体，分开没有单独的含义

顺序问题：
find /etc -name .bashrc &gt; list 2&gt;&amp;1
# 我想问为什么不能调下顺序,比如这样
find /etc -name .bashrc 2&gt;&amp;1 &gt; list
这个是从左到右有顺序的

第一种
xxx &gt; list 2&gt;&amp;1
先将要输出到stdout的内容重定向到文件，此时文件list就是这个程序的stdout，再将stderr重定向到stdout，也就是文件list

第二种
xxx 2&gt;&amp;1 &gt; list
先将要输出到stderr的内容重定向到stdout，此时会产生一个stdout的拷贝，作为程序的stderr，而程序原本要输出到stdout的内容，依然是对接在stdout原身上的，因此第二步重定向stdout，对stdout的拷贝不产生任何影响
</code></pre>

<h3 id="toc_45">/dev/null 文件</h3>

<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>

<p><code>command &gt; /dev/null</code><br/>
/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>

<p>如果希望屏蔽 stdout 和 stderr，可以这样写：<br/>
<code>command &gt; /dev/null 2&gt;&amp;1</code><br/>
<strong>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</strong></p>

<h2 id="toc_46">Shell 文件包含</h2>

<p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>

<pre><code class="language-zsh">#语法
. filename   # 注意点号(.)和文件名中间有一空格
#或
source filename

## test1.sh 文件内容
url=&quot;http://www.runoob.com&quot;
###############################
## test2.sh 文件内容
#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo &quot;菜鸟教程官网地址：$url&quot;


chmod +x test2.sh 
./test2.sh 
#菜鸟教程官网地址：http://www.runoob.com
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-04-18T21:54:46+08:00" itemprop="datePublished">2018/4/18</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15240596869056.html" itemprop="url">
		Python编程_从入门到实践</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<!--more-->

<ul>
<li>
<a href="#toc_0">Python 之禅</a>
</li>
<li>
<a href="#toc_1">PEP</a>
</li>
<li>
<a href="#toc_2">查看版本安装</a>
</li>
<li>
<a href="#toc_3">安装ipython</a>
</li>
<li>
<a href="#toc_4">语法</a>
</li>
</ul>


<h2 id="toc_0">Python 之禅</h2>

<pre><code class="language-python">&gt;&gt;&gt;
import this
</code></pre>

<h2 id="toc_1">PEP</h2>

<p>PEP (Python Enhancement Proposal) 编写Python改进提案<br/>
PEP8 建议：</p>

<pre><code>1. 缩进 4个空格
2. 行长 每行不超过80字符，注释行长不超过72字符（最初计算机终端窗口每行只能容纳79字符）
</code></pre>

<h2 id="toc_2">查看版本安装</h2>

<pre><code class="language-zsh">#查看版本
python --version
python3 --version
#查看安装位置
type -a python
type -a python3
which python
whereis python
</code></pre>

<h2 id="toc_3">安装ipython</h2>

<pre><code class="language-zsh">#ipython 语法高亮
pip3 install ipython
#安装完终端输入 ipython 
</code></pre>

<h2 id="toc_4">语法</h2>

<pre><code class="language-python">&gt;&gt;&gt;
## title, upper, lower, rstrip, str
print(&quot;hello world&quot;);
message = &quot;xuzhihua Hello Python Crash Course reader!   &quot;
print(message.title());
print(message.upper());
print(message.lower());
print(message.rstrip());
print(3*0.1);
message = &quot;Happy &quot; + str(23) + &quot; xuzhihua&quot;
print(message)


##array array[n], append, insert, del, pop, remove, sort, sorted
bicycle = [&#39;xu&#39;, &#39;zhi&#39;, &#39;hua&#39;, &#39;altman&#39;]
print(bicycle[0])
print(bicycle[-1])
print(bicycle[0])
bicycle[1] = &#39;zhizhi&#39;
print(bicycle)
bicycle.append(&#39;altman025&#39;)
print(bicycle)
bicycle.insert(2,&#39;insertTest&#39;)
print(bicycle)
del bicycle[3]
print(bicycle)
bicycle_pop = bicycle.pop();
bicycle_pop_3 = bicycle.pop(3);
print(bicycle_pop)
print(bicycle_pop_3)
print(bicycle)
bicycle.remove(&#39;zhizhi&#39;)
print(bicycle)
bicycle = [&#39;xu&#39;,&#39;zhi&#39;,&#39;hua&#39;,&#39;altman&#39;]
bicycle.sort()
print(bicycle)
bicycle = [&#39;xu&#39;,&#39;zhi&#39;,&#39;hua&#39;,&#39;altman&#39;]
print(sorted(bicycle))
print(bicycle)
bicycle.reverse()
print(bicycle)
print(bicycle)
print(len(bicycle))


##forLoop for, range, list, min, max, sum, list[m:n], ()
magicians = [&#39;alice&#39;, &#39;david&#39;, &#39;carolina&#39;]
for magician in magicians:
    print(magician + &quot;, that was a great trick&quot;)
    print(&quot;I can&#39;t to see your next trick &quot; + magician.title() + &quot;.\n&quot;)
for value in range(1,6):
    print(value)
numbers = list(range(1,10))
print(numbers)
even_number = list(range(2,11,2))
print(even_number)

squares = []
for value in range(1,11):
    squares.append(value**2)
print(squares)
squares = [value**2 for value in range(11,15)]
print(squares)

digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
print(min(digits))
print(max(digits))
print(sum(digits))

players = [&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]
print(players[0:3])
print(players[:4])
print(players[2:])
print(players[-3:])
#值赋值
players_copy = players[:]
#引用赋值
players_copy_ref = players
print(players_copy)
#元组，值不可变
dimensions = (200,500)
print(dimensions[0])
print(dimensions[1])
dimensions[0] = 100    # wrong 值不可变
dimensions = (400,400) # yes    直接赋值新元组

</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-04-12T09:54:43+08:00" itemprop="datePublished">2018/4/12</time>
			</div>
			
			 
			
		</div>
		<h1 class="title" itemprop="name"><a href="15234980833594.html" itemprop="url">
		Adobe Livecycle Designer</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<!--more-->

<ul>
<li>
<a href="#toc_0">交互式PDF</a>
<ul>
<li>
<a href="#toc_1">AcroForm</a>
</li>
<li>
<a href="#toc_2">XML Forms Architecture(XFA)</a>
</li>
</ul>
</li>
</ul>


<p><a href="http://blog.51cto.com/ifbateam/588459">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part1</a><br/>
<a href="http://blog.51cto.com/ifbateam/592944">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part2</a><br/>
<a href="http://blog.51cto.com/ifbateam/597030">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part3</a><br/>
<a href="http://blog.51cto.com/ifbateam/608319">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part4</a><br/>
<a href="http://blog.51cto.com/ifbateam/616364">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part5</a><br/>
<a href="http://blog.51cto.com/ifbateam/622809">使用Adobe LiveCycle Designer进行PDF交互式表单的设计--Part6</a></p>

<p>PDF表单</p>

<h2 id="toc_0">交互式PDF</h2>

<p>交互式PDF表单分两种：</p>

<h3 id="toc_1">AcroForm</h3>

<p>AcroForm， 它是PDF Specification 1.2 中引入的。 这种表单是从用户那里通过交互方式收集信息的字段集。交互式表单的内容和属性都是由一个交互式表单字典定义的，这个字典引用自 PDF 文件的文档类别的 AcroForm条目。</p>

<h3 id="toc_2">XML Forms Architecture(XFA)</h3>

<p>XML Forms Architecture（XFA），它是嵌入动态 XML 的  XFA 表单。XFA 提供了基于模板的语法和处理规则集，它们允许用户构建交互式表单。基于模板的语法将定义用户在其中提供数据的字段。XFA 的开放特性将提供描述交互式表单的通用 XML 语法，这是在表单处理应用程序之间执行与表单相关的交互操作的通用基础。这种开放特性意味着将在各种业务中应用 XFA。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-03-30T11:33:43+08:00" itemprop="datePublished">2018/3/30</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15223808233737.html" itemprop="url">
		git教程--廖雪峰</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p>网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰Git教程</a></p>
</blockquote>



			 
			<a href="15223808233737.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_7.html">Prev</a>  
	 <a class="next" href="all_9.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>