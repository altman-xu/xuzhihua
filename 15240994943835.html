<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	shell基础学习 - xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Case.html">Case</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="OS.html">OS</a></li>
						
						  <li id=""><a target="_self" href="Algorithms.html">Algorithms</a></li>
						
						  <li id=""><a target="_self" href="NetWork.html">NetWork</a></li>
						
						  <li id=""><a target="_self" href="Apache.html">Apache</a></li>
						
						  <li id=""><a target="_self" href="Nginx.html">Nginx</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="MySQL.html">MySQL</a></li>
						
						  <li id=""><a target="_self" href="NoSQL.html">NoSQL</a></li>
						
						  <li id=""><a target="_self" href="JVM.html">JVM</a></li>
						
						  <li id=""><a target="_self" href="Zookeeper.html">Zookeeper</a></li>
						
						  <li id=""><a target="_self" href="MQ.html">MQ</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						  <li id=""><a target="_self" href="jdkSource.html">jdkSource</a></li>
						
						  <li id=""><a target="_self" href="AboutMe.html">AboutMe</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">shell基础学习</h1>
		<div class="entry-content" itemprop="articleBody">
			<blockquote>
<p><a href="http://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>
</blockquote>

<!--more-->

<ul>
<li>
<a href="#toc_0">运行</a>
</li>
<li>
<a href="#toc_1">注释</a>
</li>
<li>
<a href="#toc_2">变量</a>
<ul>
<li>
<a href="#toc_3">定义变量</a>
</li>
<li>
<a href="#toc_4">只读变量</a>
</li>
<li>
<a href="#toc_5">删除变量</a>
</li>
<li>
<a href="#toc_6">变量类型</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">字符串</a>
<ul>
<li>
<a href="#toc_8">单引号</a>
</li>
<li>
<a href="#toc_10">拼接字符串</a>
</li>
<li>
<a href="#toc_11">获取字符串长度</a>
</li>
<li>
<a href="#toc_12">提取子字符串</a>
</li>
<li>
<a href="#toc_13">查找子字符串</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">数组</a>
<ul>
<li>
<a href="#toc_15">定义数组</a>
</li>
<li>
<a href="#toc_16">读取数组</a>
</li>
<li>
<a href="#toc_17">数组长度</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">传递参数</a>
</li>
<li>
<a href="#toc_19">运算符</a>
<ul>
<li>
<a href="#toc_20">算术运算符</a>
</li>
<li>
<a href="#toc_21">关系运算符</a>
</li>
<li>
<a href="#toc_22">布尔运算符</a>
</li>
<li>
<a href="#toc_23">逻辑运算符</a>
</li>
<li>
<a href="#toc_24">字符串运算符</a>
</li>
<li>
<a href="#toc_25">文件测试运算符</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">echo 命令</a>
</li>
<li>
<a href="#toc_27">printf 命令</a>
</li>
<li>
<a href="#toc_28">test 命令</a>
<ul>
<li>
<a href="#toc_29">数值测试</a>
</li>
<li>
<a href="#toc_30">字符串测试</a>
</li>
<li>
<a href="#toc_31">文件测试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_32">非 与 或</a>
</li>
<li>
<a href="#toc_33">流程控制</a>
<ul>
<li>
<a href="#toc_34">if else if</a>
</li>
<li>
<a href="#toc_35">for循环</a>
</li>
<li>
<a href="#toc_36">while 语句</a>
</li>
<li>
<a href="#toc_37">无限循环</a>
</li>
<li>
<a href="#toc_38">until循环</a>
</li>
<li>
<a href="#toc_39">case</a>
</li>
<li>
<a href="#toc_40">跳出循环</a>
<ul>
<li>
<a href="#toc_41">break命令</a>
</li>
<li>
<a href="#toc_42">continue</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_43">函数</a>
</li>
<li>
<a href="#toc_44">Shell 输入/输出重定向</a>
<ul>
<li>
<a href="#toc_45">/dev/null 文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">Shell 文件包含</a>
</li>
</ul>


<h2 id="toc_0">运行</h2>

<blockquote>
<p>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p>
</blockquote>

<pre><code class="language-shell">#!/bin/bash
echo &quot;Hello World !&quot;
</code></pre>

<p>运行方法:(上面的代码保存为 test.sh，并 cd 到相应目录)</p>

<ol>
<li><p>作为可执行程序</p>

<pre><code class="language-zsh">chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
</code></pre></li>
<li><p>作为解释器参数</p>

<pre><code class="language-zsh">/bin/sh test.sh
/bin/php test.php
</code></pre></li>
</ol>

<h2 id="toc_1">注释</h2>

<p>以&quot;#&quot;开头的行就是注释，会被解释器忽略。<br/>
sh里没有多行注释，只能每一行加一个#号<br/>
多行注释 变通方法</p>

<blockquote>
<p>将这些多行定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
</blockquote>

<h2 id="toc_2">变量</h2>

<h3 id="toc_3">定义变量</h3>

<pre><code class="language-zsh">your_name=&quot;qinjx&quot;
#变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界
#建议都加 花括号
echo $your_name
echo ${your_name}

for file in `ls /etc`
#或
for file in $(ls /etc)
</code></pre>

<h3 id="toc_4">只读变量</h3>

<pre><code class="language-zsh">myUrl=&quot;http://www.w3cschool.cc&quot;
readonly myUrl
#下面这句会报错
myUrl=&quot;http://www.runoob.com&quot;
</code></pre>

<h3 id="toc_5">删除变量</h3>

<pre><code class="language-zsh">unset variable_name
#变量被删除后不能再次使用。unset 命令不能删除只读变量。
myUrl=&quot;http://www.runoob.com&quot;
unset myUrl
#下面这个echo没任何输出
echo $myUrl
</code></pre>

<h3 id="toc_6">变量类型</h3>

<ol>
<li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>

<h2 id="toc_7">字符串</h2>

<p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号</p>

<h3 id="toc_8">单引号</h3>

<p>单引号字符串的限制：</p>

<ol>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>

<h3 id="toc_9">双引号</h3>

<p>双引号的优点：</p></li>
<li><p>双引号里可以有变量</p></li>
<li><p>双引号里可以出现转义字符</p></li>
</ol>

<h3 id="toc_10">拼接字符串</h3>

<pre><code class="language-zsh">your_name=&quot;qinjx&quot;
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting $greeting_1
</code></pre>

<h3 id="toc_11">获取字符串长度</h3>

<pre><code class="language-zsh">string=&quot;abcd&quot;
echo ${#string} #输出 4
</code></pre>

<h3 id="toc_12">提取子字符串</h3>

<pre><code class="language-zsh">string=&quot;runoob is a great site&quot;
echo ${string:1:4} # 输出 unoo ##从字符串第 2 个字符开始截取 4 个字符
</code></pre>

<h3 id="toc_13">查找子字符串</h3>

<pre><code class="language-zsh">string=&quot;runoob is a great company&quot;
echo `expr index &quot;$string&quot; is`  # 输出 8
</code></pre>

<h2 id="toc_14">数组</h2>

<h3 id="toc_15">定义数组</h3>

<p>在Shell中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。定义数组的一般形式为：<br/>
数组名=(值1 值2 ... 值n)</p>

<pre><code class="language-zsh">array_name=(value0 value1 value2 value3)
#或
array_name=(
value0
value1
value2
value3
)
#或 单独定义数组的各个分量：
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
</code></pre>

<h3 id="toc_16">读取数组</h3>

<p>${数组名[下标]}</p>

<pre><code class="language-zsh">valuen=${array_name[n]}
#使用@符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}
</code></pre>

<h3 id="toc_17">数组长度</h3>

<p>获取数组长度的方法与获取字符串长度的方法相同</p>

<pre><code class="language-zsh"># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
</code></pre>

<h2 id="toc_18">传递参数</h2>

<p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>

<pre><code class="language-zsh">echo &quot;Shell 传递参数实例！&quot;;
echo &quot;执行的文件名：$0&quot;;
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
##################################执行输出
$ chmod +x test.sh 
$ ./test.sh 1 2 3
#Shell 传递参数实例！
#执行的文件名：./test.sh
#第一个参数为：1
#第二个参数为：2
#第三个参数为：3
</code></pre>

<table class="reference"> <tbody> <tr> <th> 参数处理</th> <th> 说明</th> </tr> <tr> <td> $#</td> <td> 传递到脚本的参数个数</td> </tr> <tr> <td> $*</td> <td> 以一个单字符串显示所有向脚本传递的参数。<br>
如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</td> </tr> <tr> <td> $$</td> <td> 脚本运行的当前进程ID号</td> </tr> <tr> <td> $!</td> <td> 后台运行的最后一个进程的ID号</td> </tr> <tr> <td> $@</td> <td> 与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>

如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 
</td> </tr> <tr> <td> $-</td> <td> 显示Shell使用的当前选项，与<a href="/linux/linux-comm-set.html" target="_blank">set命令</a>功能相同。</td> </tr> <tr> <td> $?</td> <td> 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td> </tr> </tbody> </table>

<p>$* 与 $@ 区别：</p>

<p>相同点：都是引用所有参数。<br/>
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。</p>

<pre><code class="language-zsh">echo &quot;-- \$* 演示 ---&quot;
for i in &quot;$*&quot;; do
    echo $i
done

echo &quot;-- \$@ 演示 ---&quot;
for i in &quot;$@&quot;; do
    echo $i
done
##################################执行输出
$ chmod +x test.sh 
$ ./test.sh 1 2 3
#-- $* 演示 ---
#1 2 3
#-- $@ 演示 ---
#1
#2
#3
</code></pre>

<h2 id="toc_19">运算符</h2>

<h3 id="toc_20">算术运算符</h3>

<pre><code class="language-zsh">#!/bin/bash

val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
val=`expr $a \* $b`
echo &quot;a * b : $val&quot;
</code></pre>

<p>注意点：</p>

<ol>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
</ol>

<table class="reference">

    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                +</td>
            <td>
                加法</td>
            <td>
                `expr $a + $b` 结果为&nbsp;30。</td>
        </tr>
        <tr>
            <td>
                -</td>
            <td>
                减法</td>
            <td>
                `expr $a - $b` 结果为 -10。</td>
        </tr>
        <tr>
            <td>
                *</td>
            <td>
                乘法</td>
            <td>
                `expr $a \* $b` 结果为 &nbsp;200。</td>
        </tr>
        <tr>
            <td>
                /</td>
            <td>
                除法</td>
            <td>
                `expr $b / $a` 结果为&nbsp;2。</td>
        </tr>
        <tr>
            <td>
                %</td>
            <td>
                取余</td>
            <td>
                `expr $b % $a` 结果为&nbsp;0。</td>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                赋值</td>
            <td>
                a=$b 将把变量 b 的值赋给 a。</td>
        </tr>
        <tr>
            <td>
                ==</td>
            <td>
                相等。用于比较两个数字，相同则返回 true。</td>
            <td>
                [ $a == $b ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                不相等。用于比较两个数字，不相同则返回 true。</td>
            <td>
                [ $a != $b ] 返回 true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

val=`expr $a + $b`
echo &quot;a + b : $val&quot;

val=`expr $a - $b`
echo &quot;a - b : $val&quot;

val=`expr $a \* $b`
echo &quot;a * b : $val&quot;

val=`expr $b / $a`
echo &quot;b / a : $val&quot;

val=`expr $b % $a`
echo &quot;b % a : $val&quot;

if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;a 不等于 b&quot;
fi
</code></pre>

<h3 id="toc_21">关系运算符</h3>

<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br/>
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                -eq</td>
            <td>
                检测两个数是否相等，相等返回 true。</td>
            <td>
                [ $a -eq $b ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -ne</td>
            <td>
                检测两个数是否相等，不相等返回 true。</td>
            <td>
                [ $a -ne $b ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -gt</td>
            <td>
                检测左边的数是否大于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -gt $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -lt</td>
            <td>
                检测左边的数是否小于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -lt $b ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -ge</td>
            <td>
                检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -ge $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -le</td>
            <td>
                检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
            <td>
                [ $a -le $b ] 返回 true。</td>
        </tr>
    </tbody>
</table>

<pre><code>a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>

<h3 id="toc_22">布尔运算符</h3>

<p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                !</td>
            <td>
                非运算，表达式为 true 则返回 false，否则返回 true。</td>
            <td>
                [ ! false ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                -o</td>
            <td>
                或运算，有一个表达式为 true 则返回 true。</td>
            <td>
                [ $a -lt 20 -o $b -gt 100 ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -a</td>
            <td>
                与运算，两个表达式都为 true 才返回 true。</td>
            <td>
                [ $a -lt 20 -a $b -gt 100 ] 返回&nbsp;false。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>

<h3 id="toc_23">逻辑运算符</h3>

<p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                &amp;&amp;  </td>
            <td>
                逻辑的 AND </td>
            <td>
                [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
        </tr>
        <tr>
            <td>
                ||</td>
            <td>
                逻辑的 OR</td>
            <td>
                [[ $a -lt 100 || $b -gt 100 ]] 返回 true</td>
        </tr>
        
    </tbody>
</table>

<pre><code class="language-zsh">a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>

<h3 id="toc_24">字符串运算符</h3>

<p>下表列出了常用的字符串运算符，假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th>
                运算符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                检测两个字符串是否相等，相等返回 true。</td>
            <td>
                [ $a = $b ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                检测两个字符串是否相等，不相等返回 true。</td>
            <td>
                [ $a != $b ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -z</td>
            <td>
                检测字符串长度是否为0，为0返回 true。</td>
            <td>
                [ -z $a ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -n</td>
            <td>
                检测字符串长度是否为0，不为0返回 true。</td>
            <td>
                [ -n $a ] 返回 true。</td>
        </tr>
        <tr>
            <td>
                str</td>
            <td>
                检测字符串是否为空，不为空返回 true。</td>
            <td>
                [ $a ] 返回&nbsp;true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a = $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n $a ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>

<h3 id="toc_25">文件测试运算符</h3>

<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>

<table class="reference">
    <tbody>
        <tr>
            <th>
                操作符</th>
            <th>
                说明</th>
            <th>
                举例</th>
        </tr>
        <tr>
            <td>
                -b file</td>
            <td>
                检测文件是否是块设备文件，如果是，则返回 true。</td>
            <td>
                [ -b $file ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -c file</td>
            <td>
                检测文件是否是字符设备文件，如果是，则返回 true。</td>
            <td>
                [ -c $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -d file</td>
            <td>
                检测文件是否是目录，如果是，则返回 true。</td>
            <td>
                [ -d $file ] 返回 false。</td>
        </tr>
        <tr>
            <td>
                -f file</td>
            <td>
                检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
            <td>
                [ -f $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -g file</td>
            <td>
                检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
            <td>
                [ -g $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -k file</td>
            <td>
                检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
            <td>
                [ -k $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -p file</td>
            <td>
                检测文件是否是有名管道，如果是，则返回 true。</td>
            <td>
                [ -p $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -u file</td>
            <td>
                检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
            <td>
                [ -u $file ] 返回&nbsp;false。</td>
        </tr>
        <tr>
            <td>
                -r file</td>
            <td>
                检测文件是否可读，如果是，则返回 true。</td>
            <td>
                [ -r $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -w file</td>
            <td>
                检测文件是否可写，如果是，则返回 true。</td>
            <td>
                [ -w $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -x file</td>
            <td>
                检测文件是否可执行，如果是，则返回 true。</td>
            <td>
                [ -x $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -s file</td>
            <td>
                检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
            <td>
                [ -s $file ] 返回&nbsp;true。</td>
        </tr>
        <tr>
            <td>
                -e file</td>
            <td>
                检测文件（包括目录）是否存在，如果是，则返回 true。</td>
            <td>
                [ -e $file ] 返回&nbsp;true。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">file=&quot;/var/www/runoob/test.sh&quot;
if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>

<h2 id="toc_26">echo 命令</h2>

<p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出<br/>
命令格式：<br/>
echo string</p>

<pre><code class="language-zsh">echo &quot;It is a test&quot;
#等价
echo It is a test

#显示转义字符
echo &quot;\&quot;It is a test\&quot;&quot;
#等价
echo \&quot;It is a test\&quot;

#显示变量
#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
read name 
echo &quot;$name It is a test&quot;

#显示换行
echo -e &quot;OK! \n&quot; # -e 开启转义
echo &quot;It it a test&quot;

#显示不换行
echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行
echo &quot;It is a test&quot;

#显示结果定向至文件
echo &quot;It is a test&quot; &gt; myfile

#原样输出字符串，不进行转义或取变量(用单引号)
echo &#39;$name\&quot;&#39;

#显示命令执行结果
echo `date`
</code></pre>

<h2 id="toc_27">printf 命令</h2>

<p>printf 命令模仿 C 程序库（library）里的 printf() 程序。<br/>
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。<br/>
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p>

<p>printf 命令的语法：<br/>
printf  format-string  [arguments...]</p>

<p>printf的转义序列<br/>
<table class="reference"><tbody><tr><th><br/>
序列</th><th>说明</th></tr><tr><td><br/>
\a</td><td>警告字符，通常为ASCII的BEL字符</td></tr><tr><td><br/>
\b</td><td>后退</td></tr><tr><td><br/>
\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><br/>
\f</td><td>换页（formfeed）</td></tr><tr><td><br/>
\n </td><td>换行</td></tr><tr><td><br/>
\r</td><td>回车（Carriage return）</td></tr><tr><td><br/>
\t</td><td>水平制表符</td></tr><tr><td><br/>
\v</td><td>垂直制表符</td></tr><tr><td><br/>
\</td><td>一个字面上的反斜杠字符</td></tr><tr><td><br/>
\ddd </td><td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><br/>
\0ddd</td><td>表示1到3位的八进制值字符</td></tr></tbody></table></p>

<pre><code class="language-zsh">echo &quot;Hello, Shell&quot;
printf &quot;Hello, Shell\n&quot;

printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;
# 单引号与双引号效果一样 
printf &#39;%d %s\n&#39; 1 &quot;abc&quot; 
# 没有引号也可以输出
printf %s abcdef
# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def
printf &quot;%s\n&quot; abc def
printf &quot;%s %s %s\n&quot; a b c d e f g h i j
# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 


##################################
%d %s %c %f 格式替代符详解:
d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！
s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！
c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！
f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！
如：其中最后一个参数是 &quot;def&quot;，%c 自动截取字符串的第一个字符作为结果输出。
</code></pre>

<h2 id="toc_28">test 命令</h2>

<p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>

<h3 id="toc_29">数值测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                -eq</td>
            <td>
                等于则为真</td>
        </tr>
        <tr>
            <td>
                -ne</td>
            <td>
                不等于则为真</td>
        </tr>
        <tr>
            <td>
                -gt</td>
            <td>
                大于则为真</td>
        </tr>
        <tr>
            <td>
                -ge</td>
            <td>
                大于等于则为真</td>
        </tr>
        <tr>
            <td>
                -lt</td>
            <td>
                小于则为真</td>
        </tr>
        <tr>
            <td>
                -le</td>
            <td>
                小于等于则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo &#39;两个数相等！&#39;
else
    echo &#39;两个数不相等！&#39;
fi

result=$[num1+num2] # 注意等号两边不能有空格
echo &quot;result 为： $result&quot;
</code></pre>

<h3 id="toc_30">字符串测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                =</td>
            <td>
                等于则为真</td>
        </tr>
        <tr>
            <td>
                !=</td>
            <td>
                不相等则为真</td>
        </tr>
        <tr>
            <td>
                -z 字符串</td>
            <td>
                字符串的长度为零则为真</td>
        </tr>
        <tr>
            <td>
                -n 字符串</td>
            <td>
                字符串的长度不为零则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">num1=&quot;ru1noob&quot;
num2=&quot;runoob&quot;
if test $num1 = $num2
then
    echo &#39;两个字符串相等!&#39;
else
    echo &#39;两个字符串不相等!&#39;
fi
</code></pre>

<h3 id="toc_31">文件测试</h3>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                -e 文件名</td>
            <td>
                如果文件存在则为真</td>
        </tr>
        <tr>
            <td>
                -r 文件名</td>
            <td>
                如果文件存在且可读则为真</td>
        </tr>
        <tr>
            <td>
                -w 文件名</td>
            <td>
                如果文件存在且可写则为真</td>
        </tr>
        <tr>
            <td>
                -x 文件名</td>
            <td>
                如果文件存在且可执行则为真</td>
        </tr>
        <tr>
            <td>
                -s 文件名</td>
            <td>
                如果文件存在且至少有一个字符则为真</td>
        </tr>
        <tr>
            <td>
                -d 文件名</td>
            <td>
                如果文件存在且为目录则为真</td>
        </tr>
        <tr>
            <td>
                -f 文件名</td>
            <td>
                如果文件存在且为普通文件则为真</td>
        </tr>
        <tr>
            <td>
                -c 文件名</td>
            <td>
                如果文件存在且为字符型特殊文件则为真</td>
        </tr>
        <tr>
            <td>
                -b 文件名</td>
            <td>
                如果文件存在且为块特殊文件则为真</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">cd /bin
if test -e ./bash
then
    echo &#39;文件已存在!&#39;
else
    echo &#39;文件不存在!&#39;
fi
</code></pre>

<h2 id="toc_32">非 与 或</h2>

<p>另外，Shell还提供了 非( ! )、与( -a )、或( -o ) 三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：</p>

<pre><code class="language-zsh">cd /bin
if test -e ./notFile -o -e ./bash
then
    echo &#39;至少有一个文件存在!&#39;
else
    echo &#39;两个文件都不存在&#39;
fi
</code></pre>

<h2 id="toc_33">流程控制</h2>

<h3 id="toc_34">if else if</h3>

<p>在sh/bash里，如果else分支没有语句执行，就不要写这个else</p>

<pre><code class="language-zsh">#语法
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
#写成一行
if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi

#if else语句经常与test命令结合使用，如下所示：
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo &#39;两个数字相等!&#39;
else
    echo &#39;两个数字不相等!&#39;
fi
</code></pre>

<h3 id="toc_35">for循环</h3>

<pre><code class="language-zsh">#语法
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done

#写成一行
for var in item1 item2 ... itemN; do command1; command2… done;

for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done
for str in &#39;This is a string&#39;
do
    echo $str
done
</code></pre>

<h3 id="toc_36">while 语句</h3>

<p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件<br/>
<a href="http://www.runoob.com/linux/linux-comm-let.html">Bash let 命令</a></p>

<pre><code class="language-zsh">#语法
while condition
do
    command
done



int=1
while(( $int&lt;=5 ))
do
    echo $int
    #使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量 
    let &quot;int++&quot;
done

echo &#39;按下 &lt;CTRL-D&gt; 退出&#39;
echo -n &#39;输入你最喜欢的网站名: &#39;
while read FILM
do
    echo &quot;是的！$FILM 是一个好网站&quot;
done

</code></pre>

<h3 id="toc_37">无限循环</h3>

<pre><code class="language-zsh">while :
do
    command
done
#或
while true
do
    command
done
#或
for (( ; ; ))
</code></pre>

<h3 id="toc_38">until循环</h3>

<p>until 循环执行一系列命令直至条件为 true 时停止。<br/>
until 循环与 while 循环在处理方式上刚好相反。<br/>
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>

<pre><code class="language-zsh">#语法
until condition
do
    command
done

a=0
until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
</code></pre>

<h3 id="toc_39">case</h3>

<p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令</p>

<pre><code class="language-zsh">#语法
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac

echo &#39;输入 1 到 4 之间的数字:&#39;
echo &#39;你输入的数字为:&#39;
read aNum
case $aNum in
    1)  echo &#39;你选择了 1&#39;
    ;;
    2)  echo &#39;你选择了 2&#39;
    ;;
    3)  echo &#39;你选择了 3&#39;
    ;;
    4)  echo &#39;你选择了 4&#39;
    ;;
    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;
    ;;
esac
</code></pre>

<h3 id="toc_40">跳出循环</h3>

<h4 id="toc_41">break命令</h4>

<p>break命令允许跳出所有循环（终止执行后面的所有循环）</p>

<pre><code class="language-zsh">while :
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done
</code></pre>

<h4 id="toc_42">continue</h4>

<p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>

<pre><code class="language-zsh">while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
    #esaccase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。
done
</code></pre>

<h2 id="toc_43">函数</h2>

<pre><code class="language-zsh">#定义函数语法
#1. 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
#2. 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)
[ function ] funname [()]

{

    action;

    [return int;]

}



demoFun(){
    echo &quot;这是我的第一个 shell 函数!&quot;
}
echo &quot;-----函数开始执行-----&quot;
demoFun
echo &quot;-----函数执行完毕-----&quot;


funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;


#函数参数  在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值
#注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。
funWithParam(){
    echo &quot;第一个参数为 $1 !&quot;
    echo &quot;第二个参数为 $2 !&quot;
    echo &quot;第十个参数为 $10 !&quot;
    echo &quot;第十个参数为 ${10} !&quot;
    echo &quot;第十一个参数为 ${11} !&quot;
    echo &quot;参数总数有 $# 个!&quot;
    echo &quot;作为一个字符串输出所有参数 $* !&quot;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
</code></pre>

<table class="reference">
    <tbody>
        <tr>
            <th>
                参数处理</th>
            <th>
                说明</th>
        </tr>
        <tr>
            <td>
                $#</td>
            <td>
                传递到脚本的参数个数</td>
        </tr>
        <tr>
            <td>
                $*</td>
            <td>
                以一个单字符串显示所有向脚本传递的参数</td>
        </tr>
        <tr>
            <td>
                $$</td>
            <td>
                脚本运行的当前进程ID号</td>
        </tr>
        <tr>
            <td>
                $!</td>
            <td>
                后台运行的最后一个进程的ID号</td>
        </tr>
        <tr>
            <td>
                $@</td>
            <td>
                与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
        </tr>
        <tr>
            <td>
                $-</td>
            <td>
                显示Shell使用的当前选项，与set命令功能相同。</td>
        </tr>
        <tr>
            <td>
                $?</td>
            <td>
                显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
        </tr>
    </tbody>
</table>

<h2 id="toc_44">Shell 输入/输出重定向</h2>

<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>

<table class="reference">
    
    <tbody>
        <tr>
            <th style="width:129px;">
                命令</th>
            <th style="width:409px;">
                说明</th>
        </tr>
        <tr>
            <td>
                command &gt; file</td>
            <td>
                将输出重定向到 file。</td>
        </tr>
        <tr>
            <td>
                command &lt; file</td>
            <td>
                将输入重定向到 file。</td>
        </tr>
        <tr>
            <td>
                command &gt;&gt; file</td>
            <td>
                将输出以追加的方式重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt; file</td>
            <td>
                将文件描述符为 n 的文件重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt;&gt; file</td>
            <td>
                将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
        </tr>
        <tr>
            <td>
                n &gt;&amp; m</td>
            <td>
                将输出文件 m 和 n 合并。</td>
        </tr>
        <tr>
            <td>
                n &lt;&amp; m</td>
            <td>
                将输入文件 m 和 n 合并。</td>
        </tr>
        <tr>
            <td>
                &lt;&lt; tag</td>
            <td>
                将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
        </tr>
    </tbody>
</table>

<pre><code class="language-zsh">#输出重定向 语法
command1 &gt; file1

#######################
who &gt; users      #重定向会覆盖文件内容
who &gt;&gt; users     #不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾
cat users


#输入重定向 语法
command1 &lt; file1

#######################
wc -l users         #会输出文件名

wc -l &lt; users       #不会输出文件名 因为它仅仅知道从标准输入读取内容
</code></pre>

<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。<br/>
如果希望 stderr 重定向到 file，可以这样写：<br/>
<code>command 2 &gt; file</code><br/>
如果希望 stderr 追加到 file 文件末尾，可以这样写：<br/>
<code>command 2 &gt;&gt; file</code>  </p>

<p><strong>2 表示标准错误文件(stderr)</strong></p>

<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：<br/>
<code>command &gt; file 2&gt;&amp;1</code>或者<code>command &gt;&gt; file 2&gt;&amp;1</code></p>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：<br/>
<code>command &lt; file1 &gt;file</code><br/>
command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>

<pre><code class="language-zsh">#Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序 语法：
command &lt;&lt; delimiter
    document
delimiter

#它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。
#结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
#开始的delimiter前后的空格会被忽略掉。

wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

cat &lt;&lt; EOF
欢迎来到
菜鸟教程
www.runoob.com
EOF
</code></pre>

<pre><code class="language-zsh">## 他人笔记
command &gt; file 2&gt;&amp;1
$ command &gt;&gt; file 2&gt;&amp;1
这里的&amp;没有固定的意思

放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符，内置的文件描述符如下

1 =&gt; stdout
2 =&gt; stderr
0 =&gt; stdin
换言之 2&gt;1 代表将stderr重定向到当前路径下文件名为1的regular file中，而2&gt;&amp;1代表将stderr重定向到文件描述符为1的文件(即/dev/stdout)中，这个文件就是stdout在file system中的映射

而&amp;&gt;file是一种特殊的用法，也可以写成&gt;&amp;file，二者的意思完全相同，都等价于

&gt;file 2&gt;&amp;1
此处&amp;&gt;或者&gt;&amp;视作整体，分开没有单独的含义

顺序问题：
find /etc -name .bashrc &gt; list 2&gt;&amp;1
# 我想问为什么不能调下顺序,比如这样
find /etc -name .bashrc 2&gt;&amp;1 &gt; list
这个是从左到右有顺序的

第一种
xxx &gt; list 2&gt;&amp;1
先将要输出到stdout的内容重定向到文件，此时文件list就是这个程序的stdout，再将stderr重定向到stdout，也就是文件list

第二种
xxx 2&gt;&amp;1 &gt; list
先将要输出到stderr的内容重定向到stdout，此时会产生一个stdout的拷贝，作为程序的stderr，而程序原本要输出到stdout的内容，依然是对接在stdout原身上的，因此第二步重定向stdout，对stdout的拷贝不产生任何影响
</code></pre>

<h3 id="toc_45">/dev/null 文件</h3>

<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>

<p><code>command &gt; /dev/null</code><br/>
/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>

<p>如果希望屏蔽 stdout 和 stderr，可以这样写：<br/>
<code>command &gt; /dev/null 2&gt;&amp;1</code><br/>
<strong>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</strong></p>

<h2 id="toc_46">Shell 文件包含</h2>

<p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>

<pre><code class="language-zsh">#语法
. filename   # 注意点号(.)和文件名中间有一空格
#或
source filename

## test1.sh 文件内容
url=&quot;http://www.runoob.com&quot;
###############################
## test2.sh 文件内容
#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo &quot;菜鸟教程官网地址：$url&quot;


chmod +x test2.sh 
./test2.sh 
#菜鸟教程官网地址：http://www.runoob.com
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>