<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	redis底层数据结构 - xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Case.html">Case</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="OS.html">OS</a></li>
						
						  <li id=""><a target="_self" href="Algorithms.html">Algorithms</a></li>
						
						  <li id=""><a target="_self" href="NetWork.html">NetWork</a></li>
						
						  <li id=""><a target="_self" href="Apache.html">Apache</a></li>
						
						  <li id=""><a target="_self" href="Nginx.html">Nginx</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="MySQL.html">MySQL</a></li>
						
						  <li id=""><a target="_self" href="NoSQL.html">NoSQL</a></li>
						
						  <li id=""><a target="_self" href="Mybatis.html">Mybatis</a></li>
						
						  <li id=""><a target="_self" href="JVM.html">JVM</a></li>
						
						  <li id=""><a target="_self" href="Zookeeper.html">Zookeeper</a></li>
						
						  <li id=""><a target="_self" href="MQ.html">MQ</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						  <li id=""><a target="_self" href="jdkSource.html">jdkSource</a></li>
						
						  <li id=""><a target="_self" href="AboutMe.html">AboutMe</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">redis底层数据结构</h1>
		<div class="entry-content" itemprop="articleBody">
			<blockquote>
<p>摘自 《Redis设计与实现》<br/>
使用的redis源码是 redis3.0</p>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">简单动态字符串 SDS</a>
<ul>
<li>
<a href="#toc_1">数据结构</a>
</li>
<li>
<a href="#toc_2">用途</a>
</li>
<li>
<a href="#toc_3">与 C语言字符串比较</a>
</li>
<li>
<a href="#toc_4">SDS API</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">链表 adlist</a>
<ul>
<li>
<a href="#toc_6">数据结构</a>
</li>
<li>
<a href="#toc_7">用途</a>
</li>
<li>
<a href="#toc_8">链表 链表节点 API</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">字典 dict</a>
<ul>
<li>
<a href="#toc_10">数据结构</a>
</li>
<li>
<a href="#toc_11">哈希算法</a>
</li>
<li>
<a href="#toc_12">哈希冲突 链地址法</a>
</li>
<li>
<a href="#toc_13">rehash</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">简单动态字符串 SDS</h2>

<blockquote>
<p>简单动态字符串(simple dynamic string SDS)</p>
</blockquote>

<h3 id="toc_1">数据结构</h3>

<p>sds.h/sdshdr</p>

<pre><code class="language-c">/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
</code></pre>

<h3 id="toc_2">用途</h3>

<ol>
<li>保存数据库中的字符串值</li>
<li>AOF模块中的AOF缓冲区</li>
<li>客户端状态中的输入缓冲区</li>
</ol>

<h3 id="toc_3">与 C语言字符串比较</h3>

<p>sds 与 c语言字符串 都是以 <code>\0</code> 结尾， 所以 SDS可以直接重用一部分C字符串函数库中的函数</p>

<p>c字符串底层实现是一个N+1个字符长的数组（额外的一个自负空间用于保存<code>\0</code>）因为C字符串的长度和底层数组的长度之间存在这种关联性，所以每次增长或缩短一个C字符，程序总要对保存这个C字符的数据进行一次黁从重分配操作：</p>

<pre><code>1. 增长字符串操作(append)，在执行这个操作之前，程序需要先通过内存重分配来扩展底层数据的空间大小，如果忘了这一步就会产生 **缓冲区溢出**
2. 缩短字符串操作(trim)，在执行这个操作之后，程序需要通过内存重分配来是否字符串不再使用的那部分空间，如果忘了这一步就会产生 **内存泄露**
</code></pre>

<p>为了避免C字符串的这种缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联：在SDS中，buf数组长度不一定就是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS 的 free 属性记录。</p>

<p>通过未使用空间，SDS实现空间预分配和惰性空间释放两种优化策略</p>

<ol>
<li><p>空间预分配<br/><br/>
字符串增长操作时，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间<br/>
额外分配的未使用空间数量计算公式：</p>

<ol>
<li>如果SDS进行修改之后，SDS的长度(len)小于1MB，那么程序分配和len属性同样大小的未使用空间，这是 SDS的len和free的值相同。(eg:修改后 sds 的len变成13字节，那么程序会分配13字节的未使用空间free， buf数组实际长度 变成 13+13+1 = 27 字节)</li>
<li>如果SDS进行修改之后，SDS的长度(len)大于等于1MB，那么程序会分配1MB的未使用空间。(eg:修改后 SDS 的len编程30MB，那么程序会分配1MB的未使用空间free，buf数组的实际长度 编程 30MB+1MB+1byte)<br/></li>
</ol>

<p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，SDS将连续增长N此字符串所需的内存重分配次数从必定N次降低为最多N次。</p></li>
<li><p>惰性空间释放<br/><br/>
字符串缩短操作时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用<br/>
通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有点增长操作提供了优化</p>

<p>C字符串中的字符必须符合某种编码(如ASCII)，并且出字符串末尾外，字符串里不能包含空字符(<code>\0</code>)；SDS的api都是二进制安全的，所有SDS的api都会以处理二进制的方式来处理SDS存放在buf数组中的数据，程序不会对其中的数据做任何限制，数据在写入时是什么样的，它被读取时就是什么样的</p>

<p><img src="media/15253499429210/15253525086324.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_4">SDS API</h3>

<p><img src="media/15253499429210/15253525364468.jpg" alt=""/></p>

<h2 id="toc_5">链表 adlist</h2>

<h3 id="toc_6">数据结构</h3>

<p>adlist.h/listNode  adlist.h/list</p>

<pre><code class="language-c">/*
 * 双端链表节点
 */
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;

/*
 * 双端链表结构
 */
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

    // 链表所包含的节点数量
    unsigned long len;

} list;
</code></pre>

<p><img src="media/15253499429210/15253529296823.jpg" alt=""/></p>

<h3 id="toc_7">用途</h3>

<p>链表被应用于 列表键、发布与订阅、慢查询、监视器</p>

<h3 id="toc_8">链表 链表节点 API</h3>

<p><img src="media/15253499429210/15253527846665.jpg" alt=""/><br/>
<img src="media/15253499429210/15253528078911.jpg" alt=""/></p>

<h2 id="toc_9">字典 dict</h2>

<p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair) 的抽象数据结构<br/>
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，二每个哈希表节点就保存了字典中的一个键值对</p>

<h3 id="toc_10">数据结构</h3>

<p>dict.h/dictEntry  dict.h/dictType  dict.h/dictht  dict.h/dict</p>

<pre><code class="language-c">/*
 * 哈希表节点
 */
typedef struct dictEntry {
    
    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;


/*
 * 字典类型特定函数
 */
typedef struct dictType {

    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);

    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);

    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);

    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);

    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    
    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);

} dictType;


/*
 * 哈希表
 *
 * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。
 */
typedef struct dictht {
    
    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;
    
    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;



/*
 * 字典
 */
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

    // 目前正在运行的安全迭代器的数量
    int iterators; /* number of iterators currently running */

} dict;

</code></pre>

<p><img src="media/15253499429210/15253535601291.jpg" alt=""/></p>

<h3 id="toc_11">哈希算法</h3>

<p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面</p>

<pre><code class="language-c">#使用字典设置的哈希函数，计算键key的哈希值
hash = dict-&gt;type-&gt;hashFunction(key);

#使用哈希表的sizemask属性和哈希值，计算出索引值，根据情况不同，ht[x] 可以是ht[0]，或者ht[1]
index = hash &amp; dict-&gt;ht[x].sizemask;
</code></pre>

<p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用 MurmurHash2 算法来计算键的 哈希值</p>

<h3 id="toc_12">哈希冲突 链地址法</h3>

<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突(collision)</p>

<p>Redis的哈希表使用链地址法(separate chaining)来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单线链表连接起来，这就解决了键冲突的问题</p>

<p><img src="media/15253499429210/15253560946904.jpg" alt=""/></p>

<h3 id="toc_13">rehash</h3>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>