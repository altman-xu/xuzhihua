<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	redis底层数据结构 - xuzhihua blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="xuzhihua blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">xuzhihua blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">[Home]</a></li>
						
						  <li id=""><a target="_self" href="archives.html">[All Archives]</a></li>
						
						  <li id=""><a target="_self" href="Case.html">Case</a></li>
						
						  <li id=""><a target="_self" href="Mac.html">Mac</a></li>
						
						  <li id=""><a target="_self" href="OS.html">OS</a></li>
						
						  <li id=""><a target="_self" href="Algorithms.html">Algorithms</a></li>
						
						  <li id=""><a target="_self" href="NetWork.html">NetWork</a></li>
						
						  <li id=""><a target="_self" href="Apache.html">Apache</a></li>
						
						  <li id=""><a target="_self" href="Nginx.html">Nginx</a></li>
						
						  <li id=""><a target="_self" href="Oracle.html">Oracle</a></li>
						
						  <li id=""><a target="_self" href="MySQL.html">MySQL</a></li>
						
						  <li id=""><a target="_self" href="NoSQL.html">NoSQL</a></li>
						
						  <li id=""><a target="_self" href="Mybatis.html">Mybatis</a></li>
						
						  <li id=""><a target="_self" href="JVM.html">JVM</a></li>
						
						  <li id=""><a target="_self" href="Zookeeper.html">Zookeeper</a></li>
						
						  <li id=""><a target="_self" href="MQ.html">MQ</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java</a></li>
						
						  <li id=""><a target="_self" href="Idea.html">Idea</a></li>
						
						  <li id=""><a target="_self" href="JavaScript.html">JavaScript</a></li>
						
						  <li id=""><a target="_self" href="Shell.html">Shell</a></li>
						
						  <li id=""><a target="_self" href="Read.html">Read</a></li>
						
						  <li id=""><a target="_self" href="Video.html">Video</a></li>
						
						  <li id=""><a target="_self" href="jdkSource.html">jdkSource</a></li>
						
						  <li id=""><a target="_self" href="Fitness.html">Fitness</a></li>
						
						  <li id=""><a target="_self" href="AboutMe.html">AboutMe</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">redis底层数据结构</h1>
		<div class="entry-content" itemprop="articleBody">
			<blockquote>
<p>摘自 《Redis设计与实现》<br/>
使用的redis源码是 redis3.0</p>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">简单动态字符串 SDS   --&gt; String</a>
<ul>
<li>
<a href="#toc_1">数据结构</a>
</li>
<li>
<a href="#toc_2">用途</a>
</li>
<li>
<a href="#toc_3">与 C语言字符串比较</a>
</li>
<li>
<a href="#toc_4">SDS API</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">链表 adlist --&gt; 列表健、发布与订阅、慢查询、监视器、用链表保存多个客户端状态信息、用链表构建客户端输出缓冲区</a>
<ul>
<li>
<a href="#toc_6">数据结构</a>
</li>
<li>
<a href="#toc_7">用途</a>
</li>
<li>
<a href="#toc_8">链表特性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">字典 dict   --&gt; redis的数据库底层实现、 哈希键的底层实现之一</a>
<ul>
<li>
<a href="#toc_10">数据结构</a>
</li>
<li>
<a href="#toc_11">哈希算法</a>
</li>
<li>
<a href="#toc_12">哈希冲突 链地址法</a>
</li>
<li>
<a href="#toc_13">rehash过程</a>
</li>
<li>
<a href="#toc_14">rehash时机</a>
</li>
<li>
<a href="#toc_15">渐进式hash</a>
</li>
<li>
<a href="#toc_16">字典 API</a>
</li>
</ul>
</li>
<li>
<a href="#toc_17">跳跃表 skiplist -&gt; zset</a>
</li>
</ul>


<h2 id="toc_0">简单动态字符串 SDS   --&gt; String</h2>

<blockquote>
<p>简单动态字符串(simple dynamic string SDS)</p>
</blockquote>

<h3 id="toc_1">数据结构</h3>

<pre><code class="language-c">// sds.h/sdshdr
struct sdshdr {
    int len;        // buf 数组中已使用字节的数量  =  sds所保存字符串的长度
    int free;       // buf 数组中未使用字节的数量
    char buf[];     // 字节数组，用于保存字符串(二进制存储)  
                    // buf里面存储数据时，会与C类似，自动在最后添加&#39;\0&#39;作为结束
                    // 但是sds有len字段存储字符长度，故字符串中间可以有空格(与C区别)
};
</code></pre>

<p><img src="media/15253499429210/15995792969531.jpg" alt=""/></p>

<h3 id="toc_2">用途</h3>

<ol>
<li>保存数据库中的字符串值</li>
<li>AOF模块中的AOF缓冲区</li>
<li>客户端状态中的输入缓冲区</li>
</ol>

<h3 id="toc_3">与 C语言字符串比较</h3>

<ol>
<li>O(1)复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出(sds通过未使用空间解除字符串长度和底层数组长度的关联. buf len free)</li>
<li>减少修改字符串长度时所需的内存重分配次数(空间预分配 扩容是 len=扩容后字符串长度 free=len， 总长度=len+free+1)</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ol>

<p>sds 与 c语言字符串 都是以 <code>\0</code> 结尾， 所以 SDS可以直接重用一部分C字符串函数库中的函数</p>

<p>c字符串底层实现是一个N+1个字符长的数组（额外的一个自负空间用于保存<code>\0</code>）因为C字符串的长度和底层数组的长度之间存在这种关联性，所以每次增长或缩短一个C字符，程序总要对保存这个C字符的数据进行一次黁从重分配操作：</p>

<pre><code>1. 增长字符串操作(append)，在执行这个操作之前，程序需要先通过内存重分配来扩展底层数据的空间大小，如果忘了这一步就会产生 **缓冲区溢出**
2. 缩短字符串操作(trim)，在执行这个操作之后，程序需要通过内存重分配来是否字符串不再使用的那部分空间，如果忘了这一步就会产生 **内存泄露**
</code></pre>

<p>为了避免C字符串的这种缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联：在SDS中，buf数组长度不一定就是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS 的 free 属性记录。</p>

<p>通过未使用空间，SDS实现空间预分配和惰性空间释放两种优化策略</p>

<ol>
<li><p>空间预分配<br/><br/>
字符串增长操作时，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间<br/>
额外分配的未使用空间数量计算公式：</p>

<ol>
<li>如果SDS进行修改之后，SDS的长度(len)小于1MB，那么程序分配和len属性同样大小的未使用空间，这是 SDS的len和free的值相同。(eg:修改后 sds 的len变成13字节，那么程序会分配13字节的未使用空间free， buf数组实际长度 变成 13+13+1 = 27 字节)</li>
<li>如果SDS进行修改之后，SDS的长度(len)大于等于1MB，那么程序会分配1MB的未使用空间。(eg:修改后 SDS 的len编程30MB，那么程序会分配1MB的未使用空间free，buf数组的实际长度 编程 30MB+1MB+1byte)<br/></li>
</ol>

<p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，SDS将连续增长N此字符串所需的内存重分配次数从必定N次降低为最多N次。</p></li>
<li><p>惰性空间释放<br/><br/>
字符串缩短操作时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用<br/>
通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有点增长操作提供了优化</p>

<p>C字符串中的字符必须符合某种编码(如ASCII)，并且出字符串末尾外，字符串里不能包含空字符(<code>\0</code>)；SDS的api都是二进制安全的，所有SDS的api都会以处理二进制的方式来处理SDS存放在buf数组中的数据，程序不会对其中的数据做任何限制，数据在写入时是什么样的，它被读取时就是什么样的</p>

<p><img src="media/15253499429210/15253525086324.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_4">SDS API</h3>

<p><img src="media/15253499429210/15253525364468.jpg" alt=""/></p>

<h2 id="toc_5">链表 adlist --&gt; 列表健、发布与订阅、慢查询、监视器、用链表保存多个客户端状态信息、用链表构建客户端输出缓冲区</h2>

<h3 id="toc_6">数据结构</h3>

<pre><code class="language-c"> // adlist.h/listNode
typedef struct listNode {
    struct listNode * prev;             // 前置节点
    struct listNode * next;             // 后置节点
    void * value;                       // 节点的值     类型为指针，可以存储任意值
} listNode;
// adlist.h/list
typedef struct list {
    listNode * head;                    // 表头节点
    listNode * tail;                    // 表尾节点
    unsigned long len;                  // 链表所包含的节点数量
    void *(*dup)(void *ptr);            // 节点值复制函数，用于复制链表节点所保存的值
    void (*free)(void *ptr);            // 节点值释放函数，用于释放链表节点所保存的值
    int (*match)(void *ptr, void *key); // 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等
} list;
</code></pre>

<p><img src="media/15253499429210/15253529296823.jpg" alt=""/></p>

<h3 id="toc_7">用途</h3>

<p>链表被应用于 列表键、发布与订阅、慢查询、监视器</p>

<h3 id="toc_8">链表特性</h3>

<ol>
<li>双端: 链表节点带有prev和next指针，获取节点的前置节点和后置节点的复杂度都为O(1)</li>
<li>无环: 表头结点的prev指针和表尾节点的next指针都指向null，对链表的访问以null为终点</li>
<li>带表头指针和表尾指针: 通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</li>
<li>带链表长度计数器: 通过list结构的len属性来对len持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)</li>
<li>多台: 链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，故链表可以用于保存各种不同的数据类型
### 链表 链表节点 API
<img src="media/15253499429210/15253527846665.jpg" alt=""/>
<img src="media/15253499429210/15253528078911.jpg" alt=""/></li>
</ol>

<h2 id="toc_9">字典 dict   --&gt; redis的数据库底层实现、 哈希键的底层实现之一</h2>

<p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair) 的抽象数据结构</p>

<h3 id="toc_10">数据结构</h3>

<pre><code class="language-c"> // dict.h/dictht       哈希表 每个字典都使用两个哈希表，从而实现渐进式 rehash 。
typedef struct dictht {
    dictEntry **table;      // 哈希表数组
    unsigned long size;     // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值 sizemask=size-1
    unsigned long used;     // 该哈希表已有节点的数量
} dictht;


// dict.h/dictEntry         哈希表节点
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;              // redis大量用指针指向内存地址，这样就可以存储任意类型的数据
        uint64_t u64;
        int64_t s64;
    } v;                    // 值 可以是指针 或 unit64_t整数 或 int64_t整数
    struct dictEntry *next; // 指向下个哈希表节点，形成链表，hash冲突时用，链地址法
} dictEntry;

// dict.h/dict          字典
typedef struct dict {
    dictType *type;     // 类型特定函数
    void *privdata;     // 私有数据     type和privdata是针对不同类型的键值对，为创建多态字典而设置
    dictht ht[2];       // 哈希表 ht[0]存储数据， ht[1]扩容时使用
    int rehashidx;      // rehash时，值为h[0]已复制节点的索引，每复制完当前ht[0][rehashidx]的数据，rehashidx变自增1,当 rehash 不在进行时，值为 -1
    int iterators;      // 目前正在运行的安全迭代器的数量
} dict;

// dict.h/dictType     字典类型特定函数
typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);      // 计算哈希值的函数 默认使用Murmurhash2算法
    void *(*keyDup)(void *privdata, const void *key);   // 复制键的函数
    void *(*valDup)(void *privdata, const void *obj);   // 复制值的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  // 对比键的函数
    void (*keyDestructor)(void *privdata, void *key);   // 销毁键的函数
    void (*valDestructor)(void *privdata, void *obj);   // 销毁值的函数
} dictType;




</code></pre>

<p><img src="media/15253499429210/15253535601291.jpg" alt=""/></p>

<h3 id="toc_11">哈希算法</h3>

<p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面</p>

<pre><code class="language-c">#使用字典设置的哈希函数，计算键key的哈希值
hash = dict-&gt;type-&gt;hashFunction(key);

#使用哈希表的sizemask属性和哈希值，计算出索引值，根据情况不同，ht[x] 可以是ht[0]，或者ht[1]
index = hash &amp; dict-&gt;ht[x].sizemask;
</code></pre>

<p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用 MurmurHash2 算法来计算键的 哈希值</p>

<h3 id="toc_12">哈希冲突 链地址法</h3>

<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突(collision)</p>

<p>Redis的哈希表使用链地址法(separate chaining)来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单线链表连接起来，这就解决了键冲突的问题</p>

<p><img src="media/15253499429210/15253560946904.jpg" alt=""/></p>

<h3 id="toc_13">rehash过程</h3>

<p>rehash过程</p>

<ol>
<li><p>为字典ht[1]hash表分配存储空间(该大小取决于要执行的扩容还是收缩，也取决于ht[0]当前包含的键值对)</p>

<ol>
<li>扩容: ht[1]的大小为第一个 &gt;= ht[0].used*2的2<sup>n</sup> (2的n次方幂)</li>
<li>收缩: ht[1]的大小为第一个 &gt;= ht[0].used的2<sup>n</sup></li>
</ol></li>
<li><p>将ht[0]中所有的键值对rehash到ht[1]上(rehash是指重新计算健的哈希值和索引值，然后将键值对放到ht[1]的指定位置)</p></li>
<li><p>当ht[0]包含的键值对都迁移到ht[1]后(ht[0]变成空表)，释放ht[0],将ht[1]设置为ht[0],并在ht[1]新建一个空白哈希表，为下一次rehash做准备</p></li>
</ol>

<p>rehash过程图例<br/>
<img src="media/15253499429210/11.png" alt="11"/></p>

<h3 id="toc_14">rehash时机</h3>

<p>当一下条件中的任意一个被满足，会触发rehash</p>

<ol>
<li><strong>扩展</strong>: 服务器目前没有在执行<code>bgsave</code>命令或者<code>bgrewriteaof</code>命令，并且哈希表的负载因子大于等于1，程序会自动对哈希表进行<strong>扩展</strong>操作</li>
<li><strong>扩展</strong>: 服务器目前正在执行<code>bgsave</code>命令或者<code>bgrewriteaof</code>命令，并且哈希表的负载因子大于等于5，程序会自动对哈希表进行<strong>扩展</strong>操作</li>
<li><strong>收缩</strong>: 当哈希表的负载因子小于0.1时，程序自动对哈希表执行<strong>收缩</strong>操作</li>
</ol>

<blockquote>
<p>负载因子=哈希表已保存节点数量/哈希表大小<br/>
load_factor=ht[0].used/ht[0].size</p>
</blockquote>

<p>因为在执行<code>bgsave</code>或<code>bgrewriteaof</code>命令的过程中，redis需要创建当前服务器进程的子进程，而大多数系统都采用写时复制(copy-on-write)技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子</p>

<h3 id="toc_15">渐进式hash</h3>

<p>rehash的详细步骤:</p>

<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个hash表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash正式开始</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或则更新操作时，程序处理执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值自增1</li>
<li>随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成</li>
</ol>

<p>采用分而治之的方式，将rehash键值对所需要的计算工作均摊到字典的每个添加、删除、查找和更新操作上，从而避免集中式rehash而带来的庞大计算量</p>

<p>rehash详细过程图例<br/>
<img src="media/15253499429210/12.png" alt="12"/></p>

<h3 id="toc_16">字典 API</h3>

<p><img src="media/15253499429210/15995838873155.jpg" alt=""/></p>

<h2 id="toc_17">跳跃表 skiplist -&gt; zset</h2>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>